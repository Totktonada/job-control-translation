27 Управление заданиями
***********************

==== TODO Not checked ====

«Управлением заданиями» называется протокол [правила, соглашения?],
позволяющий пользователю переключаться между множеством «групп процессов» (или
«заданий») («process groups», «jobs») внутри одной «сессии входа». Возможности
управления заданиями организованы так, что присущее большинству программ
поведение, достигается без дополнительных усилий со стороны разработчика
программы, от него не требуются какие-либо специальные знания об управлении
заданиями. Возможно вам не понадобится материал этой главы до тех пор, пока вы
не станете писать шелл или программу входа в систему.

Для понимания материала, представленного в этой главе, вам необходимо
познакомиться с понятиями, относящимися к созданию процессов (*note Process
Creation Concepts::) и обработке сигналов (*note Signal Handling::).

* Содержание:

* Идеи [концепция?] управления заданиями::   Шелл может контроллировать задания [управлять заданиями?].
* Управление заданиями необязательно::       Не все POSIX-совместимые системы поддерживают управление заданиями.
* Управляющий терминал процесса::            Как процесс получает свой управляющий терминал.
* Доступ к управляющему терминалу::          Как процессы делят управляющий терминал.
* Осиротевшие группы процессов::             Задания, остающиеся после выхода пользователя из системы.
* Реализация шелла::                         Что необходимо шеллу для реализации управления заданиями.
* Функции для управления заданиями::         Функции для управления группами процессов.

==== TODO Not finally checked ====

27.1 Идеи [концепция?] управления заданиями
===========================================

Основное предназначение интерактивного шелла — чтение команд с
пользовательского терминала и создание процессов для выполнения программ,
соответствующих этим командам. Шелл может делать это, используя функции «fork»
(*note Creating a Process::) и «exec» (*note Executing a File::).

При запуске одиночной команды шелл запускает только один процесс, но часто
запущенная программа порождает несколько процессов. Если же вы используете
оператор «|» в команде шелла, вы явно запрашиваете запуск нескольких программ,
каждая в своём процессе. Но даже если вы запускаете только одну программу, она
может использовать множество процессов в своей работе. Например, одна команда
компиляции, такая как «cc -c foo.c», как правило использует четыре процесса
(хотя обычно в каждый момент времени используется лишь два). Или, к примеру,
задачей команды «make» является запуск других программ в отдельных процессах.

Процессы, относящиеся к одиночной команде, называются «группой процессов»
(«process group») или «заданием» («job»). Таким образом, вы можете управлять
ими как одним целым. Например, нажатие «C-c» посылает сигнал «SIGINT», который
завершает все процессы в группе, работающей на переднем плане.

Сессия («session») - это бо`льшая совокупность процессов. Обычно все процессы,
запускаемые после авторизации в системе (т.е. потомки программы входа в
систему), принадлежат одной сессии.

Каждый процесс принадлежит группе процессов. Когда процесс создаётся, он
становится членом той же группы и той же сессии, что и родительский процесс.
Вы можете поместить его в другую группу той же сессии, используя функцию
«setpgid».

Единственный способ поместить процесс в другую сессию — сделать его начальным
процессом новой сессии или «лидером сессии» («session leader»), используя
функцию «setsid». Она также помещает лидера сессии в новую группу процессов,
при этом переместить его из этой группы в другую нельзя.

Обычно новая сессия создаётся программой входа в систему, и лидер сессии — это
процесс, запускающий пользовательский шелл после успешной авторизации в
системе.

Шелл, поддерживающий управление заданиями, обязан следить за тем, что лишь
одно из заданий может безраздельно использовать терминал. В противном случае
может существовать несколько заданий, одновременно пытающихся читать с
терминала, из-за чего возникает путаница с тем, который из процессов должен
получить пользовательский ввод. Чтобы этого избежать, шелл должен
взаимодействовать с драйвером терминала с помощью протокола, описанного в этой
главе.

Шелл может дать неограниченный доступ к контролю над терминалом только одной
группе процессов в некоторый момент времени. Эта группа называется «заданием
переднего плана» («foregroud job»), именно она контролирует терминал.  Другие
группы, управляемые данным шеллом, выполняются без подобного доступа к
терминалу. Они называются «фоновыми заданиями» («background job»).

Если фоновому заданию нужно читать с управляющего терминала, это «пресекается»
драйвером терминала. Аналогично и с записью, если установлен режим «TOSTOP».
Пользователь может остановить задание переднего плана, напечатав символ SUSP
(*note Special Characters::), а программа может остановить любое задание,
послав ему сигнал «SIGSTOP». Обязанностью шелла является следить за тем, когда
задания останавливают свою работу, и уведомлять пользователей об этом. Также
шелл должен предоставлять механизм запуска остановленных заданий и механизм
переключения заданий между фоновым режимом работы и режимом переднего плана
[основной режим, интерактивный режим?].

*Note Access to the Terminal::, для дополнительной информации о вводе/выводе
на управляющий терминал.

==== TODO Not checked ====

27.2 Управление заданиями необязательно
=======================================

Не все операционные системы поддерживают управление заданиями. Система GNU
поддерживает [предоставляет поддержку?] управление заданиями, но если вы
используете библиотеку GNU на некоторых других системах, эти системы должны не
поддерживать управление заданиями сами.

Вы можете использовать макрос «_POSIX_JOB_CONTROL» для проверки поддержки
системой управления заданиями во время компиляции.  *Note System Options::.

Если управление заданиями не поддерживается, тогда только одна группа
процессов принадлежит сессии. Эта группа ведёт себя так, как если бы она
всегда находилась на переднем плане. Функции для создания дополнительных групп
просто завершаются неудачей с кодом ошибки «ENOSYS».

Когда управление заданиями не поддерживается,  макросы, обозначающие
[называющие?] соответствующие сигналы (*note Job Control Signals::), всё равно
определены,  Однако, система никогда не генерирует эти сигналы, и попытка
послать сигнал управления заданиями, а также получить или изменить
соответствующие действия (функции), приведёт к сообщению об ошибке или ни к
чему.

==== TODO Not checked ====

27.3 Управляющий терминал процесса
==================================

Одним из атрибутов процесса является [его] управляющий терминал. Дочерние
процессы, созданные с помощью «fork», наследуют управляющий терминал [от]
родительского процесса. Таким образом, все процессы в сессии наследуют
управляющий терминал [от] лидера сессии. Лидер сессии, что контролирует
терминал [управляет терминалом], называется «управляющим процессом»
(«controlling process») этого терминала.

Обычно [как правило] вы не нуждаетесь в заботе [вам не нужно
заботиться/беспокоиться о] правильности работы механизма, используемого для
назначения управляющего терминала для сессии, так как это делает система
[делается системой/об этом заботится система], когда вы авторизуетесь в
системе.

Процесс отключается от его управляющего терминала, когда он вызывает «setsid»,
чтобы стать лидером новой сессии.  *Note Process Group Functions::.

==== TODO Not checked ====

27.4 Доступ к управляющему терминалу
====================================

Процессы, относящиеся к заданию переднего плана некоторого управляющего
терминала, имеют неограниченный доступ к этому терминалу; а фоновые задания —
нет. Эта секция более детально описывает, что происходит, когда процесс из
фонового задания пытается обратиться к своему управляющему терминалу.

Когда процесс из фонового задания пытается читать со своего управляющего
терминала, группе процессов обычно посылается сигнал «SIGTTIN». Как правило
это приводит к завершению всех процессов в группе (за исключением случая,
когда они вызвали этот сигнал [check it] и не останавливаются сами). Однако,
если читающий процесс игнорирует или блокирует этот сигнал, то чтение
завершается неудачей с ошибкой «EIO».

Аналогично, когда процесс из фонового задания пытается писать на свой
управляющий терминал, умолчальным поведением является отправка сигнала
«SIGTTOU» группе процессов. Однако, это поведение можно изменить с помощью
бита «TOSTOP» в локальных флагах режимов (local modes flag) (*note Local
Modes::). Если этот бит не установлен (это значение по умолчанию), тогда
запись на управляющий терминал разрешена всегда, без отправки сигнала. Запись
также разрешена, если сигнал «SIGTTOU» игнорируется или блокируется пишущим
процессом. [А не группой процессов, один из которых пишущий?]

Большинство других операций с терминалом трактуются либо как чтение, либо как
запись. (как именно, должно быть указано в описании соответствующей операции.)

Для дополнительной информации о простых функциях «read» и «write», смотрите *note I/O Primitives::.

==== TODO Not checked ====

27.5 Осиротевшие группы процессов
=================================

Когда управляющий процесс завершается, его [соответствующий/соответствующий
ему?] терминал становится свободным и новая сессия может быть создана на нём.
(Фактически, другой пользователь может авторизоваться на этом терминале.) Это
может быть причиной проблем, если все процессы из старой сессии до сих пор
[всё ещё] пытаются использовать терминал.

Для преодоления этой проблемы, группы процессов, которые продолжают работать
даже после завершения лидера сессии маркируется [обозначается] как
«осиротевшие группы процессов» («orphaned process groups»).

Когда группа процессов становится сиротой, её процессам посылается сигнал
«SIGHUP». Обычно после этого процессы завершаются. Однако, если программа
игнорирует этот сигнал или создаёт handler для него (*note Signal Handling::),
она может выполняться далее как осиротевшая группа процессов даже после
завершения управляющего процесса; однако [но] уже без доступа к терминалу.

==== TODO Not checked ====

27.6 Реализация шелла, управляющего заданиями
=============================================

Эта секция описывает, что шелл должен делать для осуществления управления
заданиями. Здесь рассматривается подробный шаблон программы, иллюстрирующий
рассматриваемые концепции [идеи?].

* Menu и прочие ляляля [TODO].

27.6.1 Структуры данных [для] шелла

Все примеры программ, приведённые в данной главе, являются частью простого
шелла. Эта секция представляет структуры данных и полезные [служебные] функции [утилиты?],
которые используются всюду в примере.

Шаблон шелла чаще всего обращается к двум структурам данных. Тип «job»
содержит информацию о задании, которое является набором дочерних процессов,
связанных вместе пайпами. Тип «process» хранит информацию об одном дочернем
процессе. Соответствующие определения [объявления, описания?] структур данных:

     /* Представление одного [одиночного?] процесса.  */
     typedef struct process
     {
       struct process *next;       /* следующий процесс в конвеере (в pipeline) */
       char **argv;                /* для exec */
       pid_t pid;                  /* идентификатор процесса */
       char completed;             /* истина, если процесс завершён */
       char stopped;               /* истина, если процесс остановлен */
       int status;                 /* статус завершения */
     } process;

     /* Конвеер процессов (задание).  */
     typedef struct job
     {
       struct job *next;           /* следующее активное задание */
       char *command;              /* командная строка, используетя для
сообщений */
       process *first_process;     /* список процессов, относящихся к этой
задаче */
       pid_t pgid;                 /* идентификатор группы процессов */
       char notified;              /* истина, если пользователю сказано о
завершении задания */
       struct termios tmodes;      /* сохранённые параметры [TODO: check,
где-то раньше уже было modes] терминала */
       int stdin, stdout, stderr;  /* стандартные каналы ввода/вывода */
     } job;

Далее показаны несколько [некие, некоторые] служебные функции, которые
используются для оперирования объектами заданий [операций над заданиями].

     /* Поиск активного задания по PGID (идентификатору группы).  */
     job *
     find_job (pid_t pgid)
     {
       job *j;

       for (j = first_job; j; j = j->next)
         if (j->pgid == pgid)
           return j;
       return NULL;
     }

     /* Возвращает истину, если все процессы в задании остановлены или
      * завершены.  */
     int
     job_is_stopped (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed && !p->stopped)
           return 0;
       return 1;
     }

     /* Возвращает истину, если все процессы в задании завершены.  */
     int
     job_is_completed (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed)
           return 0;
       return 1;
     }

==== Not finally checked ====

27.6.2 Инициализация шелла

Когда шелл, стандартно управляющий заданиями, запустился, он должен
действовать аккуратно, если был вызван из другого шелла, который уже
осуществляет управление заданиями.

Дочерний шелл, запущенный интерактивно, должен убедиться, что он помещён на
передний план родительским шеллом перед тем, как начать сам управлять
заданиями. Он делает это, получая начальный идентификатор группы процессов с
помощью функции «getpgrp» и сравнивая его с идентификатором группы текущего
задания переднего плана, связанного с управляющим терминалом. Последний
идентификатор можно получить, используя функцию «tcgetpgrp».

Если дочерний шелл запущен в фоновом режиме, он должен остановиться, послав
сигнал «SIGTTIN» своей группе процессов. Он не может самопроизвольно поместить
себя на передний план; он должен ждать пока пользователь скажет родительскому
шеллу сделать это. Если дочерний шелл продолжает выполнение [«is continued
again»], он должен повторить проверку и остановиться снова, если он всё ещё не
на переднем плане.

Однажды дочерний шелл, будучи помещённым на передний план родительским шеллом,
сможет начать управлять заданиями. Для этого он вызывает «setpgid», чтобы
поместить себя в свою собственную группу процессов, и затем «tcsetpgrp», чтобы
поместить эту группу на передний план.

Когда шелл начинает управлять заданиями, ему следует игнорировать все сигналы
останова подконтрольных заданий, для того, чтобы случайно не завершить самого
себя. Вы можете сделать это, установив действие для всех сигналов останова в
«SIG_IGN».

Дочерний шелл, который запущен в неинтерактивном режиме, не может и не должен
осуществлять управление заданиями. Он должен оставить все созданные им
процессы в той группе, которой принадлежит сам; это позволяет неинтерактивному
шеллу и его дочерним процессам обрабатываться родительским шеллом как единое
задание. Сделать это легко — просто не используйте никакие из примитивов
управления заданиями — но вы должны не забыть заставить шелл действовать
таким образом.

Далее представлен код инициализации для примера шелла, который иллюстрирует
всё вышесказанное [не нижесказанное?].

     /* Следите за атрибутами шелла.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Перед тем как продолжить, убедитесь, что шелл работает в интерактивном
	    режиме как задание переднего плана. */

     void
     init_shell ()
     {

       /* Проверьте, работаем ли мы в интерактивном режиме.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Ждите, пока мы не окажемся на переднем плане.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Игнорируйте интерактивные сигналы и сигналы, предназначенные для
			  управления заданиями.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Поместите себя в свою собственную группу процессов.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Перехватите управление терминалом.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Сохраните атрибуты шелла по-умолчанию.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }

27.6.3 Запуск заданий

Однажды шелл берёт ответственность за управление заданиями на [его]
управляющем терминале, он [шелл] может запустить задания в ответ на команды,
набираемые пользователем.

Для создания процессов в группе, вы используете некоторые [семейства функций]
функции «fork» и «exec», описанные в *note Process Creation Concepts::. С
этого момента множество дочерних процессов включают в себя, хотя, вещи немного
более сложные и вы должны позаботиться о делании вещей правильно. Иначе [в
противном случае], плохое [отвратительное] состояние гонки («race condition»)
может быть результатом.

Вы имеете два варианта, как структурировать дерево родительских-детских
отношений между процессами. Вы можете либо сделать все процессы в группе
дочерними по отношению к процессу шелла, или вы можете сделать один процесс в
группе быть преком остальных процессов группы. Пример шелла, представленный в
этой главе, использует первый подход, поскольку это до некоторой степени
упрощает вычисления [досл.: счетоводство, бухгалтерия].

Как каждый процесс форкается, он должне поместить себя в новую группу, с
помощью вызова «setpgid»; см. *note Process Group Functions::. Первый процесс
в новой группе называется лидером группы процессов («process group leader»), и
его идентификатор (process ID) называется идентификатором группы (process
group ID).

Шелл должен также вызвать «setpgid» для помещения каждого дочернего процесса в
новую группу процессов. Это делается для предотвразения потенциальной проблемы
со временем: каждый дочерний процесс должен быть помещён в группу процессов
перед началом выполнения новой программы, и шелл зависит от наличия всех
дочерних процессов в группе [группах?] перед продолжением выполнения. Если два
дочерних процесса и шелл вызовут «setpgid», это гарантирует, что правильные
вещи случатся вне зависимости от того, какой процесс сделал это первым.

Если задание было запущено как задание переднего плана, новая группа процессов
также нуждается в помещении на передний план на управляющем терминале. Сделать
это можно, используя «tcsetpgrp». Опять же, это должно быть сделано как
шеллом, так и каждым из дочерних процессов, для избажения [предотвращения]
состояния гонки (race condition).

Далее каждый дочерний процесс должен сбросить реакцию на сигналы.

В течение [в процессе — путаница] инициализации процесс шелла устанавливает
игнорирование сигналов управления заданиями; см. *note Initializing the
Shell::. В результате этого все [вновь?] созданные дочерние процессы также
игнорируют эти сигналы (по наследству). Это определённо нежелательно, каждый
процесс должен явно установить действия для этих сигналов назад в «SIG_DFL»
только после форка.

Когда шелл следует этому соглашению, приложения могут принимать
[притворяться?], что они корректно наследуют [от родительского процесса]
реакцию на данные сигналы. Но каждое приложение ответственно за то, чтобы не
смешивать [пачкать, портить?] реакцию на сигналы [управление сигналами]
останова. Приложение, которое отключило нормальную интерпретацию символа SUSP
должно предоставлять другие механизмы для останова задания пользователем.
Когда пользователь вызывает этот механизм, программа должна послать сигнал
«SIGTSTP» своей группе процессов, но верным [более верным или тоже верным?]
поведением будет послеть его своему процессу.  *Note Signaling Another
Process::.

Наконец, каждый дочерний процесс должен вызвать «exec» (если предыдущие этапы
прошли нормально). Также это момент времени, когда перенаправления стандартных
потоков [может, каналов?] ввода-вывода должны быть вызваны.  *Note Duplicating
Descriptors::, для объяснения того, как это сделать. 

Ниже представлены функции из примера шелла, ответственные за [предназначенные
для] запуск программ. Эти функции выполняются каждым дочерним процессом
непосредственно после того, как они отфоркались от шелла и никогда не
возвращают управление (never returns).

     void
     launch_process (process *p, pid_t pgid,
                     int infile, int outfile, int errfile,
                     int foreground)
     {
       pid_t pid;

       if (shell_is_interactive)
         {
           /* Поместите процесс в группу и получите соответствующий этой
              группе терминал, если таковой имеется.
              Это делается как шеллом, так и каждым из дочерних процессов, во
              избежание возможного состояния гонки (race condition).  */
           pid = getpid ();
           if (pgid == 0) pgid = pid;
           setpgid (pid, pgid);
           if (foreground)
             tcsetpgrp (shell_terminal, pgid);

           /* Установите умолчальных слушателей для сигналов управления
            * заданиями.  */
           signal (SIGINT, SIG_DFL);
           signal (SIGQUIT, SIG_DFL);
           signal (SIGTSTP, SIG_DFL);
           signal (SIGTTIN, SIG_DFL);
           signal (SIGTTOU, SIG_DFL);
           signal (SIGCHLD, SIG_DFL);
         }

       /* Установите стандартные каналы ввода-вывода для нового процесса.  */
       if (infile != STDIN_FILENO)
         {
           dup2 (infile, STDIN_FILENO);
           close (infile);
         }
       if (outfile != STDOUT_FILENO)
         {
           dup2 (outfile, STDOUT_FILENO);
           close (outfile);
         }
       if (errfile != STDERR_FILENO)
         {
           dup2 (errfile, STDERR_FILENO);
           close (errfile);
         }

       /* Выполнить новый процесс [программу?].  Убедиться, что мы вышли.  */
       execvp (p->argv[0], p->argv);
       perror ("execvp");
       exit (1);
     }

Если шелл не запущен интерактивно, эта функция не делает ничего с группами
процессов и сигналами. Помните, что шелл, не выполняющий управление заданиями,
должен держать все дочерние процессы в той же группе процессов, что и сам
шелл.

Далее, нижеследующие функции на самом деле запускают полную задачу. После
создания дочерних процессов, эти функции вызывают некие другие функции для
того, чтобы поместить вновь созданные задания на передний план или в фон; это
обсуждается в *note Foreground and Background::.

     void
     launch_job (job *j, int foreground)
     {
       process *p;
       pid_t pid;
       int mypipe[2], infile, outfile;

       infile = j->stdin;
       for (p = j->first_process; p; p = p->next)
         {
           /* Установите пайпы, если необходимо.  */
           if (p->next)
             {
               if (pipe (mypipe) < 0)
                 {
                   perror ("pipe");
                   exit (1);
                 }
               outfile = mypipe[1];
             }
           else
             outfile = j->stdout;

           /* Ответвите дочерний процесс.  */
           pid = fork ();
           if (pid == 0)
             /* Это дочерний процесс.  */
             launch_process (p, j->pgid, infile,
                             outfile, j->stderr, foreground);
           else if (pid < 0)
             {
               /* Ветвление (fork) не удалось.  */
               perror ("fork");
               exit (1);
             }
           else
             {
               /* Это родительский процесс.  */
               p->pid = pid;
               if (shell_is_interactive)
                 {
                   if (!j->pgid)
                     j->pgid = pid;
                   setpgid (pid, j->pgid);
                 }
             }

           /* Привести в порядок пайпы [перенаправления].  */
           if (infile != j->stdin)
             close (infile);
           if (outfile != j->stdout)
             close (outfile);
           infile = mypipe[0];
         }

       format_job_info (j, "launched");

       if (!shell_is_interactive)
         wait_for_job (j);
       else if (foreground)
         put_job_in_foreground (j, 0);
       else
         put_job_in_background (j, 0);
     }
