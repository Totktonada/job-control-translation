==== Not finally checked ====

27.1 Идеи управления заданиями

Основное предназначение интерактивного шелла — чтение команд с
пользовательского терминала и создание процессов для выполнения программ,
соответствующих этим командам. Шелл может делать это, используя функции «fork»
(*note Creating a Process::) и «exec» (*note Executing a File::).

При запуске одиночной команды шелл запускает только один процесс, но часто
запущенная программа порождает несколько процессов. Если же вы используете
оператор «|» в команде шелла, вы явно запрашиваете запуск нескольких программ,
каждая в своём процессе. Но даже если вы запускаете только одну программу, она
может использовать множество процессов в своей работе. Например, одна команда
компиляции, такая как «cc -c foo.c», как правило использует четыре процесса
(хотя обычно в каждый момент времени используется лишь два). Или, к примеру,
задачей команды «make» является запуск других программ в отдельных процессах.

Процессы, относящиеся к одиночной команде, называются «группой процессов»
(«process group») или «заданием» («job»). Таким образом, вы можете управлять
ими как одним целым. Например, нажатие «C-c» посылает сигнал «SIGINT», который
завершает все процессы в группе, работающей на переднем плане.

Сессия («session») - это бо`льшая совокупность процессов. Обычно все процессы,
запускаемые после авторизации в системе (т.е. потомки программы входа в
систему), принадлежат одной сессии.

Каждый процесс принадлежит группе процессов. Когда процесс создаётся, он
становится членом той же группы и той же сессии, что и родительский процесс.
Вы можете поместить его в другую группу той же сессии, используя функцию
«setpgid».

Единственный способ поместить процесс в другую сессию — сделать его начальным
процессом новой сессии или «лидером сессии» («session leader»), используя
функцию «setsid». Она также помещает лидера сессии в новую группу процессов,
при этом переместить его из этой группы в другую нельзя.

Обычно новая сессия создаётся программой входа в систему, и лидер сессии — это
процесс, запускающий пользовательский шелл после успешной авторизации в
системе.

Шелл, поддерживающий управление заданиями, обязан следить за тем, что лишь
одно из заданий может безраздельно использовать терминал. В противном случае
может существовать несколько заданий, одновременно пытающихся читать с
терминала, из-за чего возникает путаница с тем, который из процессов должен
получить пользовательский ввод. Чтобы этого избежать, шелл должен
взаимодействовать с драйвером терминала с помощью протокола, описанного в этой
главе.

Шелл может дать неограниченный доступ к контролю над терминалом только одной
группе процессов в некоторый момент времени. Эта группа называется «заданием
переднего плана» («foregroud job»), именно она контролирует терминал.  Другие
группы, управляемые данным шеллом, выполняются без подобного доступа к
терминалу. Они называются «фоновыми заданиями» («background job»).

Если фоновому заданию нужно читать с управляющего терминала, это «пресекается»
драйвером терминала. Аналогично и с записью, если установлен режим «TOSTOP».
Пользователь может остановить задание переднего плана, напечатав символ SUSP
(*note Special Characters::), а программа может остановить любое задание,
послав ему сигнал «SIGSTOP». Обязанностью шелла является следить за тем, когда
задания останавливают свою работу, и уведомлять пользователей об этом. Также
шелл должен предоставлять механизм запуска остановленных заданий и механизм
переключения заданий между фоновым режимом работы и режимом переднего плана
[основной режим, интерактивный режим?].

*Note Access to the Terminal::, для дополнительной информации о вводе/выводе
на управляющий терминал.

==== Not checked ====

27.2 Управление заданиями необязательно

Не все операционные системы поддерживают управление заданиями. Система GNU
поддерживает [предоставляет поддержку?] управление заданиями, но если вы
используете библиотеку GNU на некоторых других системах, эти системы должны не
поддерживать управление заданиями сами.

Вы можете использовать макрос «_POSIX_JOB_CONTROL» для проверки поддержки
системой управления заданиями во время компиляции.  *Note System Options::.

Если управление заданиями не поддерживается, тогда только одна группа
процессов принадлежит сессии. Эта группа ведёт себя так, как если бы она
всегда находилась на переднем плане. Функции для создания дополнительных групп
просто завершаются неудачей с кодом ошибки «ENOSYS».

Когда управление заданиями не поддерживается,  макросы, обозначающие
[называющие?] соответствующие сигналы (*note Job Control Signals::), всё равно
определены,  Однако, система никогда не генерирует эти сигналы, и попытка
послать сигнал управления заданиями, а также получить или изменить
соответствующие действия (функции), приведёт к сообщению об ошибке или ни к
чему.

==== Not checked ====

27.3 Управляющий терминал процесса

Одним из атрибутов процесса является [его] управляющий терминал. Дочерние
процессы, созданные с помощью «fork», наследуют управляющий терминал [от]
родительского процесса. Таким образом, все процессы в сессии наследуют
управляющий терминал [от] лидера сессии. Лидер сессии, что контролирует
терминал [управляет терминалом], называется «управляющим процессом»
(«controlling process») этого терминала.

Обычно [как правило] вы не нуждаетесь в заботе [вам не нужно
заботиться/беспокоиться о] правильности работы механизма, используемого для
назначения управляющего терминала для сессии, так как это делает система
[делается системой/об этом заботится система], когда вы авторизуетесь в
системе.

Процесс отключается от его управляющего терминала, когда он вызывает «setsid»,
чтобы стать лидером новой сессии.  *Note Process Group Functions::.

==== Not checked ====

27.4 Доступ к управляющему терминалу

Процессы, относящиеся к заданию переднего плана некоторого управляющего
терминала, имеют неограниченный доступ к этому терминалу; а фоновые задания —
нет. Эта секция более детально описывает, что происходит, когда процесс из
фонового задания пытается обратиться к своему управляющему терминалу.

Когда процесс из фонового задания пытается читать со своего управляющего
терминала, группе процессов обычно посылается сигнал «SIGTTIN». Как правило
это приводит к завершению всех процессов в группе (за исключением случая,
когда они вызвали этот сигнал [check it] и не останавливаются сами). Однако,
если читающий процесс игнорирует или блокирует этот сигнал, то чтение
завершается неудачей с ошибкой «EIO».

Аналогично, когда процесс из фонового задания пытается писать на свой
управляющий терминал, умолчальным поведением является отправка сигнала
«SIGTTOU» группе процессов. Однако, это поведение можно изменить с помощью
бита «TOSTOP» в локальных флагах режимов (local modes flag) (*note Local
Modes::). Если этот бит не установлен (это значение по умолчанию), тогда
запись на управляющий терминал разрешена всегда, без отправки сигнала. Запись
также разрешена, если сигнал «SIGTTOU» игнорируется или блокируется пишущим
процессом. [А не группой процессов, один из которых пишущий?]

Большинство других операций с терминалом трактуются либо как чтение, либо как
запись. (как именно, должно быть указано в описании соответствующей операции.)

Для дополнительной информации о простых функциях «read» и «write», смотрите *note I/O Primitives::.

==== Not checked ====

27.5 Осиротевшие группы процессов

Когда управляющий процесс завершается, его [соответствующий/соответствующий
ему?] терминал становится свободным и новая сессия может быть создана на нём.
(Фактически, другой пользователь может авторизоваться на этом терминале.) Это
может быть причиной проблем, если все процессы из старой сессии до сих пор
[всё ещё] пытаются использовать терминал.

Для преодоления этой проблемы, группы процессов, которые продолжают работать
даже после завершения лидера сессии маркируется [обозначается] как
«осиротевшие группы процессов» («orphaned process groups»).

Когда группа процессов становится сиротой, её процессам посылается сигнал
«SIGHUP». Обычно после этого процессы завершаются. Однако, если программа
игнорирует этот сигнал или создаёт handler для него (*note Signal Handling::),
она может выполняться далее как осиротевшая группа процессов даже после
завершения управляющего процесса; однако [но] уже без доступа к терминалу.

==== Not finally checked ====

27.6.2 Инициализация шелла

Когда шелл, стандартно управляющий заданиями, запустился, он должен
действовать аккуратно, если был вызван из другого шелла, который уже
осуществляет управление заданиями.

Дочерний шелл, запущенный интерактивно, должен убедиться, что он помещён на
передний план родительским шеллом перед тем, как начать сам управлять
заданиями. Он делает это, получая начальный идентификатор группы процессов с
помощью функции "getpgrp" и сравнивая его с идентификатором группы текущего
задания переднего плана, связанного с управляющим терминалом. Последний
идентификатор можно получить, используя функцию "tcgetpgrp".

Если дочерний шелл запущен в фоновом режиме, он должен остановиться, послав
сигнал "SIGTTIN" своей группе процессов. Он не может самопроизвольно поместить
себя на передний план; он должен ждать пока пользователь скажет родительскому
шеллу сделать это. Если дочерний шелл продолжает выполнение ["is continued
again"], он должен повторить проверку и остановиться снова, если он всё ещё не
на переднем плане.

Однажды дочерний шелл, будучи помещённым на передний план родительским шеллом,
сможет начать управлять заданиями. Для этого он вызывает "setpgid", чтобы
поместить себя в свою собственную группу процессов, и затем "tcsetpgrp", чтобы
поместить эту группу на передний план.

Когда шелл начинает управлять заданиями, ему следует игнорировать все сигналы
останова подконтрольных заданий, для того, чтобы случайно не завершить самого
себя. Вы можете сделать это, установив действие для всех сигналов останова в
"SIG_IGN".

Дочерний шелл, который запущен в неинтерактивном режиме, не может и не должен
осуществлять управление заданиями. Он должен оставить все созданные им
процессы в той группе, которой принадлежит сам; это позволяет неинтерактивному
шеллу и его дочерним процессам обрабатываться родительским шеллом как единое
задание. Сделать это легко -- просто не используйте никакие из примитивов
управления заданиями -- но вы должны не забыть заставить шелл действовать
таким образом.

Далее представлен код инициализации для примера шелла, который иллюстрирует
всё вышесказанное [не нижесказанное?].

     /* Следите за атрибутами шелла.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Перед тем как продолжить, убедитесь, что шелл работает в интерактивном
	    режиме как задание переднего плана. */

     void
     init_shell ()
     {

       /* Проверьте, работаем ли мы в интерактивном режиме.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Ждите, пока мы не окажемся на переднем плане.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Игнорируйте интерактивные сигналы и сигналы, предназначенные для
			  управления заданиями.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Поместите себя в свою собственную группу процессов.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Перехватите управление терминалом.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Сохраните атрибуты шелла по-умолчанию.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }
