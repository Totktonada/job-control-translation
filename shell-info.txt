27 Управление заданиями
***********************

==== TODO Not checked ====

«Управлением заданиями» называется протокол [правила, соглашения?],
позволяющий пользователю переключаться между множеством «групп процессов» (или
«заданий») («process groups», «jobs») внутри одной «сессии входа». Возможности
управления заданиями организованы так, что присущее большинству программ
поведение достигается без дополнительных усилий со стороны разработчика
программы, от него не требуются какие-либо специальные знания об управлении
заданиями. Возможно, вам не понадобится материал этой главы до тех пор, пока вы
не станете писать шелл или программу входа в систему.

Для понимания материала, представленного в этой главе, вам необходимо
познакомиться с понятиями, относящимися к созданию процессов (*note Process
Creation Concepts::) и обработке сигналов (*note Signal Handling::).

* Содержание:

* Идеи [концепция?] управления заданиями::   Шелл может контроллировать задания [управлять заданиями?].
* Управление заданиями необязательно::       Не все POSIX-совместимые системы поддерживают управление заданиями.
* Управляющий терминал процесса::            Как процесс получает свой управляющий терминал.
* Доступ к управляющему терминалу::          Как процессы делят управляющий терминал.
* Осиротевшие группы процессов::             Задания, остающиеся после выхода пользователя из системы.
* Реализация шелла::                         Что необходимо шеллу для реализации управления заданиями.
* Функции для управления заданиями::         Функции для управления группами процессов.

==== TODO Not finally checked ====

27.1 Идеи [концепция?] управления заданиями
===========================================

Основное предназначение интерактивного шелла — чтение команд с
пользовательского терминала и создание процессов для выполнения программ,
соответствующих этим командам. Шелл может делать это, используя функции «fork»
(*note Creating a Process::) и «exec» (*note Executing a File::).

При запуске одиночной команды (прим. перев.: вероятно, подразумевался конвеер)
шелл запускает только один процесс, но часто запущенная программа порождает
несколько процессов. Если же вы используете оператор «|» в команде шелла, вы
явно запрашиваете запуск нескольких программ отдельными процессами. Но даже
если вы запускаете только одну программу, она может использовать множество
процессов в своей работе. Например, одна команда компиляции, такая как «cc -c
foo.c», как правило использует четыре процесса (хотя обычно в каждый момент
времени используется лишь два). Или, к примеру, задачей команды «make»
является запуск других программ в отдельных процессах.

Процессы, относящиеся к одиночной команде, называются «группой процессов»
(«process group») или «заданием» («job»). Таким образом, вы можете управлять
ими как одним целым. Например, нажатие «C-c» посылает сигнал «SIGINT», который
завершает все процессы в группе, работающей на переднем плане.

Сессия («session») - это бо`льшая совокупность процессов. Обычно все процессы,
запускаемые после авторизации в системе (т.е. потомки программы входа в
систему), принадлежат одной сессии.

Каждый процесс принадлежит группе процессов. Когда процесс создаётся, он
становится членом той же группы и той же сессии, что и родительский процесс.
Вы можете поместить его в другую группу той же сессии, используя функцию
«setpgid».

Единственный способ поместить процесс в другую сессию — сделать его начальным
процессом новой сессии или «лидером сессии» («session leader»), используя
функцию «setsid». Она также помещает лидера сессии в новую группу процессов,
при этом переместить его из этой группы в другую нельзя.

Обычно новая сессия создаётся программой входа в систему, и лидер сессии — это
процесс, запускающий пользовательский шелл после успешной авторизации в
системе.

Шелл, поддерживающий управление заданиями, обязан следить за тем, что лишь
одно из заданий может безраздельно использовать терминал. В противном случае
может существовать несколько заданий, одновременно пытающихся читать с
терминала, из-за чего возникает путаница с тем, который из процессов должен
получить пользовательский ввод. Чтобы этого избежать, шелл должен
взаимодействовать с драйвером терминала с помощью протокола, описанного в этой
главе.

Шелл может дать неограниченный доступ к контролю над терминалом только одной
группе процессов в некоторый момент времени. Эта группа называется «заданием
переднего плана» («foregroud job»), именно она контролирует терминал.  Другие
группы, управляемые данным шеллом, выполняются без подобного доступа к
терминалу. Они называются «фоновыми заданиями» («background job»).

Если фоновому заданию нужно читать с управляющего терминала, оно
приостанавливается драйвером терминала. Аналогично и с записью, если
установлен режим «TOSTOP». Пользователь может приостановить задание переднего
плана, напечатав символ SUSP (*note Special Characters::), а программа может
остановить любое задание, послав ему сигнал «SIGSTOP». Обязанностью шелла
является следить за тем, когда задания останавливают свою работу, и уведомлять
пользователей об этом. Также шелл должен предоставлять механизм запуска
остановленных заданий и механизм переключения заданий между фоновым режимом
работы и режимом переднего плана [основной режим, интерактивный режим?].

*Note Access to the Terminal::, для дополнительной информации о вводе/выводе
на управляющий терминал.

==== TODO Not checked ====

27.2 Управление заданиями необязательно
=======================================

Не все операционные системы поддерживают управление заданиями. Система GNU
поддерживает [предоставляет поддержку?] управление заданиями, но если вы
используете библиотеку GNU на некоторых других системах, эти системы должны не
поддерживать управление заданиями сами.

Вы можете использовать макрос «_POSIX_JOB_CONTROL» для проверки поддержки
системой управления заданиями во время компиляции.  *Note System Options::.

Если управление заданиями не поддерживается, тогда только одна группа
процессов принадлежит сессии. Эта группа ведёт себя так, как если бы она
всегда находилась на переднем плане. Функции для создания дополнительных групп
просто завершаются неудачей с кодом ошибки «ENOSYS».

Когда управление заданиями не поддерживается,  макросы, обозначающие
[называющие?] соответствующие сигналы (*note Job Control Signals::), всё равно
определены,  Однако, система никогда не генерирует эти сигналы, и попытка
послать сигнал управления заданиями, а также получить или изменить
соответствующие действия (функции), приведёт к сообщению об ошибке или ни к
чему.

==== TODO Not checked ====

27.3 Управляющий терминал процесса
==================================

Одним из атрибутов процесса является [его] управляющий терминал. Дочерние
процессы, созданные с помощью «fork», наследуют управляющий терминал [от]
родительского процесса. Таким образом, все процессы в сессии наследуют
управляющий терминал [от] лидера сессии. Лидер сессии, что контролирует
терминал [управляет терминалом], называется «управляющим процессом»
(«controlling process») этого терминала.

Обычно [как правило] вы не нуждаетесь в заботе [вам не нужно
заботиться/беспокоиться о] правильности работы механизма, используемого для
назначения управляющего терминала для сессии, так как это делает система
[делается системой/об этом заботится система], когда вы авторизуетесь в
системе.

Процесс отключается от его управляющего терминала, когда он вызывает «setsid»,
чтобы стать лидером новой сессии.  *Note Process Group Functions::.

==== TODO Not checked ====

27.4 Доступ к управляющему терминалу
====================================

Процессы, относящиеся к заданию переднего плана некоторого управляющего
терминала, имеют неограниченный доступ к этому терминалу; а фоновые задания —
нет. Эта секция более детально описывает, что происходит, когда процесс из
фонового задания пытается обратиться к своему управляющему терминалу.

Когда процесс из фонового задания пытается читать со своего управляющего
терминала, группе процессов обычно посылается сигнал «SIGTTIN». Как правило
это приводит к завершению всех процессов в группе (за исключением случая,
когда они вызвали этот сигнал [check it] и не останавливаются сами). Однако,
если читающий процесс игнорирует или блокирует этот сигнал, то чтение
завершается неудачей с ошибкой «EIO».

Аналогично, когда процесс из фонового задания пытается писать на свой
управляющий терминал, умолчальным поведением является отправка сигнала
«SIGTTOU» группе процессов. Однако, это поведение можно изменить с помощью
бита «TOSTOP» в локальных флагах режимов (local modes flag) (*note Local
Modes::). Если этот бит не установлен (это значение по умолчанию), тогда
запись на управляющий терминал разрешена всегда, без отправки сигнала. Запись
также разрешена, если сигнал «SIGTTOU» игнорируется или блокируется пишущим
процессом. [А не группой процессов, один из которых пишущий?]

Большинство других операций с терминалом трактуются либо как чтение, либо как
запись. (как именно, должно быть указано в описании соответствующей операции.)

Для дополнительной информации о простых функциях «read» и «write», смотрите *note I/O Primitives::.

==== TODO Not checked ====

27.5 Осиротевшие группы процессов
=================================

Когда управляющий процесс завершается, его [соответствующий/соответствующий
ему?] терминал становится свободным и новая сессия может быть создана на нём.
(Фактически, другой пользователь может авторизоваться на этом терминале.) Это
может быть причиной проблем, если все процессы из старой сессии до сих пор
[всё ещё] пытаются использовать терминал.

Для преодоления этой проблемы, группы процессов, которые продолжают работать
даже после завершения лидера сессии маркируется [обозначается] как
«осиротевшие группы процессов» («orphaned process groups»).

Когда группа процессов становится сиротой, её процессам посылается сигнал
«SIGHUP». Обычно после этого процессы завершаются. Однако, если программа
игнорирует этот сигнал или создаёт обработчик для него (*note Signal
Handling::), она может выполняться далее как осиротевшая группа процессов даже
после завершения управляющего процесса; однако [но] уже без доступа к
терминалу.

==== TODO Not checked ====

27.6 Реализация шелла, управляющего заданиями
=============================================

Эта секция описывает, что шелл должен делать для осуществления управления
заданиями. Здесь рассматривается подробный шаблон программы, иллюстрирующий
рассматриваемые концепции [идеи?].

* Menu и прочие ляляля [TODO].

27.6.1 Структуры данных [для] шелла
-----------------------------------

Все примеры программ, приведённые в данной главе, являются частью простого
шелла. Эта секция представляет структуры данных и полезные [служебные] функции [утилиты?],
которые используются всюду в примере.

Шаблон шелла чаще всего обращается к двум структурам данных. Тип «job»
содержит информацию о задании, которое является набором дочерних процессов,
связанных вместе пайпами. Тип «process» хранит информацию об одном дочернем
процессе. Соответствующие определения [объявления, описания?] структур данных:

     /* Представление одного [одиночного?] процесса.  */
     typedef struct process
     {
       struct process *next;       /* следующий процесс в конвеере (в pipeline) */
       char **argv;                /* для exec */
       pid_t pid;                  /* идентификатор процесса */
       char completed;             /* истина, если процесс завершён */
       char stopped;               /* истина, если процесс приостановлен */
       int status;                 /* статус завершения */
     } process;

     /* Конвеер процессов (задание).  */
     typedef struct job
     {
       struct job *next;           /* следующее активное задание */
       char *command;              /* командная строка, используется для
сообщений */
       process *first_process;     /* список процессов, относящихся к этой
задаче */
       pid_t pgid;                 /* идентификатор группы процессов */
       char notified;              /* истина, если пользователю сказано о
завершении задания */
       struct termios tmodes;      /* сохранённые параметры [TODO: check,
где-то раньше уже было modes] терминала */
       int stdin, stdout, stderr;  /* стандартные каналы ввода/вывода */
     } job;

Далее показаны несколько [некие, некоторые] служебные функции, которые
используются для оперирования объектами заданий [операций над заданиями].

     /* Поиск активного задания по PGID (идентификатору группы).  */
     job *
     find_job (pid_t pgid)
     {
       job *j;

       for (j = first_job; j; j = j->next)
         if (j->pgid == pgid)
           return j;
       return NULL;
     }

     /* Возвращает истину, если все процессы в задании приостановлены или
        завершены.  */
     int
     job_is_stopped (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed && !p->stopped)
           return 0;
       return 1;
     }

     /* Возвращает истину, если все процессы в задании завершены.  */
     int
     job_is_completed (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed)
           return 0;
       return 1;
     }

==== Not finally checked ====

27.6.2 Инициализация шелла
--------------------------

Когда шелл, стандартно управляющий заданиями, запустился, он должен
действовать аккуратно, если был вызван из другого шелла, который уже
осуществляет управление заданиями.

Дочерний шелл, запущенный интерактивно, должен убедиться, что он помещён на
передний план родительским шеллом перед тем, как начать сам управлять
заданиями. Он делает это, получая начальный идентификатор группы процессов с
помощью функции «getpgrp» и сравнивая его с идентификатором группы текущего
задания переднего плана, связанного с управляющим терминалом. Последний
идентификатор можно получить, используя функцию «tcgetpgrp».

Если дочерний шелл запущен в фоновом режиме, он должен [при?]остановиться,
послав сигнал «SIGTTIN» своей группе процессов. Он не может самопроизвольно
поместить себя на передний план; он должен ждать пока пользователь скажет
родительскому шеллу сделать это. Если дочерний шелл продолжает выполнение [«is
continued again»], он должен повторить проверку и [при?]остановиться снова,
если он всё ещё не на переднем плане.

Однажды дочерний шелл, будучи помещённым на передний план родительским шеллом,
сможет начать управлять заданиями. Для этого он вызывает «setpgid», чтобы
поместить себя в свою собственную группу процессов, и затем «tcsetpgrp», чтобы
поместить эту группу на передний план.

Когда шелл начинает управлять заданиями, ему следует игнорировать все сигналы
останова подконтрольных заданий, для того, чтобы случайно не завершить самого
себя. Вы можете сделать это, установив действие для всех сигналов останова в
«SIG_IGN».

Дочерний шелл, который запущен в неинтерактивном режиме, не может и не должен
осуществлять управление заданиями. Он должен оставить все созданные им
процессы в той группе, которой принадлежит сам; это позволяет неинтерактивному
шеллу и его дочерним процессам обрабатываться родительским шеллом как единое
задание. Сделать это легко — просто не используйте никакие из примитивов
управления заданиями — но вы должны не забыть заставить шелл действовать
таким образом.

Далее представлен код инициализации для примера шелла, который иллюстрирует
всё вышесказанное [не нижесказанное?].

     /* Следите за атрибутами шелла.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Перед тем как продолжить, убедитесь, что шелл работает в интерактивном
	    режиме как задание переднего плана. */

     void
     init_shell ()
     {

       /* Проверьте, работаем ли мы в интерактивном режиме.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Ждите, пока мы не окажемся на переднем плане.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Игнорируйте интерактивные сигналы и сигналы, предназначенные для
			  управления заданиями.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Поместите себя в свою собственную группу процессов.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Перехватите управление терминалом.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Сохраните атрибуты шелла по-умолчанию.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }

27.6.3 Запуск заданий
---------------------

Однажды шелл берёт ответственность за управление заданиями на его управляющем
терминале, и тогда шелл может запускать задания в ответ на команды, набираемые
пользователем.

Для создания процессов в группе, вы используете некоторые функции из семейств
«fork» и «exec», они описанны в *note Process Creation Concepts::. С помощью
только этих функций можно запускать программы в дочерних процессах, но, если
не учитывать некоторых (чуть более сложных) деталей, то может возникнуть
состояние гонки («race condition»). Поэтому вы должны позаботиться о том,
чтобы делать всё в правильном порядке [правильно?].

Есть два варианта структурирования дерева родственных отношений между
процессами. Вы можете сделать все процессы в группе дочерними по отношению к
процессу шелла [Вы можете форкнуть все процессы во всех группах от процесса
шелла] или сделать один процесс в группе предком остальных процессов группы.
Пример шелла, представленный в этой главе, использует первый подход, поскольку
это до некоторой степени упрощает вычисления [досл.: счетоводство,
бухгалтерия].

Каждый из процессов, как только форкается, должен поместить себя в новую
группу, с помощью вызова «setpgid»; см. *note Process Group Functions::.
Первый процесс в новой группе называется лидером группы процессов («process
group leader»), его идентификатор («process ID») называется идентификатором
группы («process group ID»).

Шелл должен также вызвать «setpgid» для того, чтобы поместить каждый дочерний
процесс в новую группу. Это делается для предотвращения потенциальной проблемы
синхронизации: каждый дочерний процесс нужно поместить в [соответствующую?]
группу процессов перед началом выполнения новой программы. Сделать это —
обязанность шелла.  Вызов «setpgid» как дочерним процессом, так и шеллом
гарантирует, что всё пройдёт правильно, вне зависимости от того, какой процесс
сделал это первым.

Если задание было запущено как задание переднего плана, новую группу процессов
также нужно поместить на передний план на управляющем терминале. Сделать
это можно, используя «tcsetpgrp». Опять же, это нужно сделать как шеллу, так и
каждому из дочерних процессов, чтобы избежать состояния гонки.

Далее каждый дочерний процесс должен сбросить реакцию на сигналы.

В течение [в процессе — путаница] инициализации процесс шелла устанавливает
игнорирование сигналов управления заданиями; см. *note Initializing the
Shell::. В результате этого все [вновь?] созданные дочерние процессы также
игнорируют эти сигналы (по наследству). Это определённо нежелательно, и каждый
процесс должен явно установить действия для этих сигналов назад в «SIG_DFL»
непосредственно после форка.

Когда шелл следует этому соглашению, приложения могут предпологать, что
реакция на сигналы корректно наследуется от родительского процесса. Но каждое
приложение ответственно за то, чтобы не портить реакцию на сигналы [управление
сигналами] останова. Приложение, отключивщее нормальную интерпретацию символа
SUSP, должно предоставлять другие механизмы для останова [приостановки?]
задания пользователем. Когда пользователь вызывает [активирует?] этот
механизм, программа должна послать сигнал «SIGTSTP» своей группе процессов, а
не только своему процессу.  *Note Signaling Another Process::.

Наконец, каждый дочерний процесс должен вызвать «exec» (если предыдущие этапы
прошли нормально). Здесь же (прим. перев.: если это необходимо) надо
осуществить перенаправление стандартных каналов ввода-вывода.  В *Note
Duplicating Descriptors:: рассказано, как это сделать.

Ниже представлены функции из примера шелла, ответственные за [предназначенные
для] запуск программ. Эти функции выполняются каждым дочерним процессом
непосредственно после того, как они отфоркались от шелла, и никогда не
возвращают управление («never returns»).

     void
     launch_process (process *p, pid_t pgid,
                     int infile, int outfile, int errfile,
                     int foreground)
     {
       pid_t pid;

       if (shell_is_interactive)
         {
           /* Поместите процесс в группу и получите соответствующий этой
              группе терминал, если таковой имеется.
              Это делается как шеллом, так и каждым из дочерних процессов, во
              избежание возможного состояния гонки.  */
           pid = getpid ();
           if (pgid == 0) pgid = pid;
           setpgid (pid, pgid);
           if (foreground)
             tcsetpgrp (shell_terminal, pgid);

           /* Установите обработчики по-умолчанию для сигналов управления
              заданиями.  */
           signal (SIGINT, SIG_DFL);
           signal (SIGQUIT, SIG_DFL);
           signal (SIGTSTP, SIG_DFL);
           signal (SIGTTIN, SIG_DFL);
           signal (SIGTTOU, SIG_DFL);
           signal (SIGCHLD, SIG_DFL);
         }

       /* Установите стандартные каналы ввода-вывода для нового процесса.  */
       if (infile != STDIN_FILENO)
         {
           dup2 (infile, STDIN_FILENO);
           close (infile);
         }
       if (outfile != STDOUT_FILENO)
         {
           dup2 (outfile, STDOUT_FILENO);
           close (outfile);
         }
       if (errfile != STDERR_FILENO)
         {
           dup2 (errfile, STDERR_FILENO);
           close (errfile);
         }

       /* Выполнить новый процесс [программу?].  Убедиться, что мы вышли.  */
       execvp (p->argv[0], p->argv);
       perror ("execvp");
       exit (1);
     }

Если шелл не запущен интерактивно, эта функция не делает ничего с группами
процессов и сигналами. Помните, что шелл, не выполняющий управление заданиями,
должен держать все дочерние процессы в той же группе процессов, что и сам
шелл.

Нижеследующие функции фактически запускают полную задачу. После создания
дочерних процессов, эти функции вызывают некие другие функции для того, чтобы
поместить вновь созданные задания на передний план или в фон; это обсуждается
в *note Foreground and Background::.

     void
     launch_job (job *j, int foreground)
     {
       process *p;
       pid_t pid;
       int mypipe[2], infile, outfile;

       infile = j->stdin;
       for (p = j->first_process; p; p = p->next)
         {
           /* Установите пайпы, если необходимо.  */
           if (p->next)
             {
               if (pipe (mypipe) < 0)
                 {
                   perror ("pipe");
                   exit (1);
                 }
               outfile = mypipe[1];
             }
           else
             outfile = j->stdout;

           /* Ответвите дочерний процесс.  */
           pid = fork ();
           if (pid == 0)
             /* Это дочерний процесс.  */
             launch_process (p, j->pgid, infile,
                             outfile, j->stderr, foreground);
           else if (pid < 0)
             {
               /* Ветвление (fork) не удалось.  */
               perror ("fork");
               exit (1);
             }
           else
             {
               /* Это родительский процесс.  */
               p->pid = pid;
               if (shell_is_interactive)
                 {
                   if (!j->pgid)
                     j->pgid = pid;
                   setpgid (pid, j->pgid);
                 }
             }

           /* Привести в порядок пайпы [перенаправления].  */
           if (infile != j->stdin)
             close (infile);
           if (outfile != j->stdout)
             close (outfile);
           infile = mypipe[0];
         }

       format_job_info (j, "launched");

       if (!shell_is_interactive)
         wait_for_job (j);
       else if (foreground)
         put_job_in_foreground (j, 0);
       else
         put_job_in_background (j, 0);
     }

27.6.4 [Выполнение] На переднем плане и в фоне
----------------------------------------------

==== TODO Not checked ====

Рассмотрим действия, которые должен сделать шелл, запускающий задание на
переднем плане; и как они отличаются от тех действий, которые надо сделать при
запуске фонового задания.

Когда запускается задание переднего плана, первое, что должен сделать шелл —
получить доступ к управляющему терминалу с помощью «tcsetpgrp». Потом щелл
должен ждать приостановки или завершения процессов в этой группе. Более
подробно это обсудается в *note Stopped and Terminated Jobs::.

Когда все процессы в группе завершены или приостановлены, шелл должен получить
обратно [вернуть] терминал для своей группы процессов с помощью повторного
вызова «tcsetpgrp». Нормальной [обычной, стандартной] реакцией всех процессов
в задании на [полученный] сигнал останова является одновременная приостановка.
Причиной сигнала останова может быть попытка ввода/вывода со стороны фонового
процесса или ввод пользователем символа SUSP.

Задание переднего плана может покинуть терминал в странном состоянии [м.б.
просто «может изменить параметры терминала»?], поэтому перед тем, как
продолжить, шелл должен восстановить сохранённые [им заранее] параметры
терминала. Если задание [всего лишь] приостановлено, первое, что должен
сделать шелл — сохранить текущие параметры терминала. Их нужно будет
восстановить позже, когда задание продолжит выполнение [возобновит
работу/выполнение]. Функции для работы [взаимодействия] с параметрами
терминала называются «tcgetattr» и «tcsetattr»; они описаны в *note Terminal
Modes::.

Ниже показаны функции [из] примера шелла, делающие всё вышеперечисленное.

     /* Поместить задание J на передний план. Если CONT не равен нулю,
        то восстановить параметры терминала и послать группе процессов
        сигнал «SIGCONT» для того, чтобы «разбудить» их перед блокировкой.
        [перед тем как заблокировать себя/приостановиться] */

     void
     put_job_in_foreground (job *j, int cont)
     {
       /* Поместить задание на передний план. */
       tcsetpgrp (shell_terminal, j->pgid);

       /* Если необходимо, послать заданию сигнал продолжения. */
       if (cont)
         {
           tcsetattr (shell_terminal, TCSADRAIN, &j->tmodes);
           if (kill (- j->pgid, SIGCONT) < 0)
             perror ("kill (SIGCONT)");
         }

       /* Ждать отчётов. */
       wait_for_job (j);

       /* [Вернуть] Поместить шелл обратно на передний план. */
       tcsetpgrp (shell_terminal, shell_pgid);

       /* Восстановить параметры терминала, принадлежащие шеллу. */
       tcgetattr (shell_terminal, &j->tmodes);
       tcsetattr (shell_terminal, TCSADRAIN, &shell_tmodes);
     }

Если группа процессов запускается как фоновое задание, шелл должен сам
оставаться на переднем плане и продолжать читать команды с терминала.

Для того, чтобы поместить задание в фон, ничего другого в нашем примере шелла
делать не нужно. Вот функции, используемые для этого:

     /* Поместить задание в фон. Если аргумент cont — истина (true), то
        послать группе процессов сигнал «SIGCONT», чтобы «разбудить». */

     void
     put_job_in_background (job *j, int cont)
     {
       /* Если необходимо, послать заданию сигнал продолжения. */
       if (cont)
         if (kill (-j->pgid, SIGCONT) < 0)
           perror ("kill (SIGCONT)");
     }

27.6.5 Приостановленные и завершённые задания
---------------------------------------------

==== TODO Not checked ====

Когда запускается задание [в оригинале процесс, но так звучит лучше] переднего
плана, шелл должен заблокироваться [?] до тех пор, пока все процессы в задании
не завершатся или приостановлятся. Это можно сделать с помощью функции
«waitpid»; см. *note Process Completion::. Используйте параметр [опцию?]
«WUNTRACED», чтобы получать статусную информацию о приоставленных процессах
наравне с завершёнными.

Также шелл должен проверять статус фоновых заданий, о завершении или
приостановке которых можно сообщить пользователю; это можно сделать с помощью
«waitpid» с параметром [опцией?] «WHOHANG». Хорошее место для вставки такой
проверки на завершение или приостановку [или просто «этой проверки»?] —
непосредственно перед выводом приглашения для новой команды.

Шелл также может получать асинхронные уведомления о том, что стала доступной
статусная информация о дочернем процессе, с помощью создания обработчика для
сигнала «SIGCHLD». *Note Signal Handling::.

В данном примере шелла, сигнал «SIGCHLD» обычно игнорируется из-за проблемы
повторного использования [или одновременного обращения к?] глобальных структур
данных, используемых шеллом [или управляющих шеллом?]. Но в некоторые особые
моменты времени (когда шелл не использует эти структуры данных) — такие, как
ожидание ввода с терминала — имеет смысл включить обработчик для «SIGCHLD».
Функция для моментальной [synchronous] проверки статуса (в данном случае,
«do_job_notification») может также использоваться в этом обработчике.

Ниже представлены части примера шелла, отвечающие за проверку статуса заданий
и печати сообщений [отчётов] для пользователя.

     /* Сохранить статус процесса PID, возвращённый функцией waitpid.
        Вернуть 0, если всё прошло хорошо, иначе ненулевое значение. */

     int
     mark_process_status (pid_t pid, int status)
     {
       job *j;
       process *p;

       if (pid > 0)
         {
           /* Обновить запись [ведомость, отчёт?] для процесса. */
           for (j = first_job; j; j = j->next)
             for (p = j->first_process; p; p = p->next)
               if (p->pid == pid)
                 {
                   p->status = status;
                   if (WIFSTOPPED (status))
                     p->stopped = 1;
                   else
                     {
                       p->completed = 1;
                       if (WIFSIGNALED (status))
                         fprintf (stderr, "%d: Terminated by signal %d.\n",
                                  (int) pid, WTERMSIG (p->status));
                     }
                   return 0;
                  }
           fprintf (stderr, "No child process %d.\n", pid);
           return -1;
         }
       else if (pid == 0 || errno == ECHILD)
         /* Нет процессов, готовых для отчёта [к отчёту?]. */
         return -1;
       else {
         /* Другие фатальные ошибки. */
         perror ("waitpid");
         return -1;
       }
     }

     /* Проверка на процессы с доступной статусной информацией, без
        блокировки. */

     void
     update_status (void)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED|WNOHANG);
       while (!mark_process_status (pid, status));
     }

     /* Проверка на процессы с доступной статусной информацией, блокируется
        после получения отчётов от всех процессов в полученном задании. */

     void
     wait_for_job (job *j)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED);
       while (!mark_process_status (pid, status)
              && !job_is_stopped (j)
              && !job_is_completed (j));
     }

     /* Сформировать сообщение с информацией о статусе задания для
        пользователя. */

     void
     format_job_info (job *j, const char *status)
     {
       fprintf (stderr, "%ld (%s): %s\n", (long)j->pgid, status, j->command);
     }

     /* Уведомить пользователя о приостановленных и завершённых заданиях.
        Удалить завершённые задания из списка активных. */

     void
     do_job_notification (void)
     {
       job *j, *jlast, *jnext;
       process *p;

       /* Обновить статусную информацию для [о?] дочерних процессов. */
       update_status ();

       jlast = NULL;
       for (j = first_job; j; j = jnext)
         {
           jnext = j->next;

           /* Если все процессы завершены, сообщить пользователю о завершении
              задания и удалить его из списка активных заданий. */
           if (job_is_completed (j)) {
             format_job_info (j, "completed");
             if (jlast)
               jlast->next = jnext;
             else
               first_job = jnext;
             free_job (j);
           }

           /* Уведомить пользователя о приостановленных заданиях; пометить их,
              поскольку мы хотим сделать это лишь один раз. */
           else if (job_is_stopped (j) && !j->notified) {
             format_job_info (j, "stopped");
             j->notified = 1;
             jlast = j;
           }

           /* Не сообщать о любых выполняющихся заданиях. */
           else
             jlast = j;
         }
     }

27.6.6 Запуск приостановленных заданий
--------------------------------------

==== TODO Not checked ====

Шелл может продолжить возобновить работу приостановленного задания, послав
соответствующей группе процессов сигнал «SIGCONT». Если нужно продолжить
выполнение задания на переднем плане, первым делом шелл должен вызвать
«tcsetpgrp» для получения доступа к терминалу и восстановить сохранённые
настройки терминала.  После возобновления работы задания на переднем плане,
шелл должен ждать приостановки или завершения задания, как если бы оно было
запущено на переднем плане изначально.

Пример шелла обрабатывает как только что созданные, так и возобновляющие
выполнение задания с помощью пары функций «put_job_in_foreground» и
«put_job_in_background». Определения этих функций даны в *note Foreground and
Background::. Когда требуется продолжить приостановленное задание, нужно
передать в одну из этих функций ненулевое значение в качестве аргумента CONT.
Тогда сигнал «SIGCONT» будет послан [отправлен?] и параметры [опции?]
терминала сброшены.

Здесь представлены только функции для обновления внутренних значений
[структур] шелла в соответствии с тем, что задание продолжает выполнение:

     /* Пометить приостановленное задание J как [запущенное снова/вновь
        запущенное]. */

     void
     mark_job_as_running (job *j)
     {
       Process *p;

       for (p = j->first_process; p; p = p->next)
         p->stopped = 0;
       j->notified = 0;
     }

     /* Возобновить выполнение задания J. */

     void
     continue_job (job *j, int foreground)
     {
       mark_job_as_running (j);
       if (foreground)
         put_job_in_foreground (j, 1);
       else
         put_job_in_background (j, 1);
     }

27.6.7 Недостающее
------------------

==== TODO Not checked ====

Куски [отрывки] кода из примера шелла, включённые в эту главу — лишь только
часть полного [целого] шелла. В частности, никто не говорит о том, как для
структур данных «job» и «programm» (прим. перев.: вероятно, имеется ввиду
«process») распределяется память и как проходит их инициализация.

Большинство настоящих шеллов предоставляют сложный пользовательский интерфейс,
который имеет поддержку командного языка, переменных, аббревиатур,
подстановок, шаблонов для подбора имён файлов и тому подобного. Всё это очень
сложно изложить здесь! Вместо этого мы сосредоточили рассмотрение на том, как
реализуются основные моменты создания процессов и на функциях управления
заданиями, которые могут быть вызваны из такого шелла.

Это таблица, обобщющая информацию о ключевых точках [моментах], представленных
нами [ранее]:

`void init_shell (void)'
     Инициализировать внутренние структуры шелла.  *Note Initializing the
     Shell::.

`void launch_job (job *J, int FOREGROUND)'
     Запустить задание J как задание переднего плана или фоновое. *Note
     Launching Jobs::.

`void do_job_notification (void)'
     Проверить и уведомить обо всех завершённых или приостановленных заданиях.
     Может быть вызываться одновременно или из обработчика для сигнала «SIGCHLD».
     *Note Stopped and Terminated Jobs::.

`void continue_job (job *J, int FOREGROUND)'
     Продолжить выполнение задания J.  *Note Continuing Stopped Jobs::.

Конечно, настоящий шелл также захочет предоставить другие функции для
управления заданиями. Например, команды для вывода списка активных заданий или
для посылки сигнала (такого, как «SIGKILL») заданию.

27.7 Функции для управления заданиями
=====================================

==== TODO Not checked ====

Эта секция содержит подробное описание функций, относящихся к управлению
заданиями.

* Содержание:

* Опознание терминала::          Определение имени управляющего терминала.
* Функции групп процессов::      Функции для управления группами процессов.
* Функции доступа к терминалу::  Функции для управления доступом к терминалу.

27.7.1 Опознание управляющего терминала
---------------------------------------

==== TODO Not checked ====

Для получения имени файла, которое можно использовать для доступа [to open] к
управляющему терминалу, вы можете использовать функцию «ctermid». В библиотеке
GNU она всегда возвращает строку "/dev/tty". Это специальное «магическое»
[«волшебное»] имя файла [или просто «значение»?], которое ссылается на
управляющий терминал текущего процесса (если таковой имеется). Для получения
уникального имени устройства терминала используйте «ttyname»; *note Is It a
Terminal::.

   Функция «ctermid» объявлена в заголовочном файле «stdio.h».

 -- Function: char * ctermid (char *STRING)
    Функция «ctermid» возвращает строку, содержащую имя файла,
    соответствующего управляющему терминалу текущего процесса. Если STRING —
    не нулевой указатель, то это должен быть массив, который может хранить как
    минимум «L_ctermid» символов; строка будет помещена в этот массив. В
    противном случае, будет возвращён указатель на строку в статической
    области памяти, которая может быть перезаписана последующими вызовами
    данной функции.

    Если имя файла не может быть определено по любой из возможных причин, то
    будет возвращена пустая строка. Даже если имя файла было возвращено,
    доступ к нему не гарантируется.

 -- Macro: int L_ctermid
     Значением данного макроса является целочисленное константное выражение,
     соответствующее размеру строки, которого достаточно для хранения имени
     файла, возвращённого функцией «ctermid».

   См. также функции «isatty» и «ttyname» в *note Is It a Terminal::.

27.7.2 Функции групп процессов

==== TODO Not checked ====

Здесь описаны функции для управления группами процессов. Для их использования
ваша программа должна включать (include) заголовочные файлы «sys/types.h» и
«unistd.h».

 -- Function: pid_t setsid (void)
     Функция «setsid» создаёт новую сессию. Вызывающий процесс становится
     лидером сессии и помещается в новую группу с таким же идентификатором
     (process group ID), как и у данного процесса (process ID).
     Непосредственно после вызова данной функции других процессов в новой
     группе не будет, равно как и не будет других групп в новой сессии.

     Также, в результате работы этой функции, процесс перестаёт быть
     привязанным к какому-либо управляющему терминалу.

     Если функция «setsid» завершается успешно, то она возвращает
     идентификатор новой группы вызывающего процесса. Возвращаемое значение
     «-1» означает ошибку. Для этой функции определены следующие состояния
     ошибок «errno»:

     «EPERM»
           Вызывающий процесс уже является лидером группы или другая группа
           занимает нужный идентификатор.

 -- Function: pid_t getsid (pid_t PID)
     Функция «getsid» возвращает идентификатор группы процессов лидера той
     сессии, которой принадлежит указанный процесс. Если PID равен «0»,
     подразумевается текущий процесс.

     При ошибке возвращается «-1» и устанавливается переменная «errno».  Для
     этой функции определены следующие состояния ошибок «errno»:

    «ESRCH»
          Нет процессов с данным идентификатором PID.

    «EPERM»
          Вызывающий процесс и процесс, указанный [заданный] с помощью PID,
          находятся в разных сессиях, и реализация не разрешает доступ из
          текущего процесса к идентификатору группы лидера той сессии, к
          которой принадлежит процесс с идентификатором PID.

Функция «getpgrp» имеет два определения: одно из BSD Unix, а другое из
стандарта POSIX.1. Выбранная возможность test macros [TODO] (*note Feature
Test Macros::) определяет, которое из определений вы получаете. А именно, если
вы определили «_BSD_SOURCE», то получите версию из BSD; если вы определили
«_POSIX_SOURCE» или «_GNU_SOURCE», то получите версию POSIX. Программы,
написанные для старых систем BSD, не будут включать (include) «unistd.h»,
который определяет «getpgrp» специально под «_BSD_SOURCE». Вы должны
компоновать такие программы с опцией «-lbsd-compat» для получения определений
из BSD.

 -- POSIX.1 Function: pid_t getpgrp (void)
     Определение функции «getpgrp» из POSIX.1 возвращает идентификатор группы
     вызывающего процесса.

 -- BSD Function pid_t getpgrp (pid_t PID)
     Определение функции «getpgrp» из BSD возвращает идентификатор группы
     процесса PID. Вы можете указать значение «0» для аргумента PID для
     получения информации о вызывающем процессе.

 -- System V Function: int getpgid (pid_t PID)
     Функция «getpgid» — то же самое, что и функция «getpgrp» в BSD. Возвращает
     идентификатор группы процесса PID. Можно указать «0» в качестве аргумента
     PID для получения информации о вызывающем процессе.

При ошибке возвращается значение «-1» и устанавливается переменная «errno».
Для этой функции определены следующие состояния ошибок «errno»:

    «ESRCH»
          Нет процесса с данным идентификатором PID. Вызывающий процесс и
          процесс, указанный [заданный] с помощью PID, находятся в разных
          сессиях, и реализация не разрешает доступ из текущего процесса к
          идентификатору группы лидера той сессии, к которой принадлежит
          процесс с идентификатором PID.

 -- Function: int setpgid (pid_t PID, pid_t PGID)
     Функция «setpgid» помещает процесс PID в группу PGID. PID и PGID могут
     быть нулями для обозначения соответствующего значения вызывающего
     процесса.

Эта функция завершается неудачей на системах, которые не поддерживают
управление заданиями. *Note Job Control is Optional::, для дополнительной
информации.

Если операция успешна, то функция «setpgid» возвращает нуль. В противном
случае, возвращается «-1». Для этой функции определены следующие состояния
ошибок «errno»:

    «EACCES»
          Дочерний процесс с идентификатором PID выполнил функцию «exec» после
          того, как ответвился (was forked).

    «EINVAL»
          Значение PGID некорректно.

    «ENOSYS»
          Система не поддерживает управление заданиями.

    «EPERM»
         Определяемый аргументом PID процесс — лидер сессии, или принадлежит
         не той же сессии, что вызывающий процесс, или значение аргумента PGID
         не соответствует идентификатору группы из той же сессии, что и
         вызывающий процесс.

    «ESRCH»
         Определяемый аргументом PID процесс не является вызывающим
         процессом или его дочерним.

 -- Function: int setpgrp (pid_t PID, pid_t PGID)
     Это имя функции «setpgid» из BSD Unix. Обе функции абсолютно идентичны.

27.7.3 Функции для управления доступом к терминалу

==== TODO Not checked ====

Это функции для чтения и установки группы процессов переднего плана
определённого терминала. Для их использования ваша программа [ваше
приложение?] должна включать (include) заголовочные файлы «sys/types.h» и
«unistd.h».

Хотя эти функции принимают в качестве аргумента файловый дескриптор,
определяющий [задающий] устройство терминала, задание переднего плана
ассоциировано с файлом терминала само по себе и специально открывать файл [в
оригинале file descriptor] не требуется [не следует/не нужно?].

 -- Function: pid_t tcgetpgrp (int FILEDES)
     Эта функция возвращает идентификатор группы процессов переднего плана,
     ассоциированной с открытым на дескрипторе FILEDES терминалом.

     Если нет групп процессов переднего плана, то возвращается число, большее
     «1», которое не соответствует ни одному идентификатору группы. Эта
     ситуация может иметь место [Это может произойти], если все процессы в
     задании, которое прежде было на переднем плане, завершились и других
     заданий на передний план перемещено не было.

     При ошибке возвращается значение «-1». Для этой функции определены
     следующие состояния ошибок «errno»:

   «EBADF»
         Аргумент FILEDES не является корректным файловым дескриптором.

   «ENOSYS»
         Система не поддерживает управление заданиями.

   «ENOTTY»
         Файл терминала, соответствующий аргументу FILEDES, не является
         управляющим терминалом вызывающего процесса.

 -- Function: int tcsetpgrp (int FILEDES, pid_t PGID)
     Эта функция используется для установки группы процессов переднего плана
     некотором терминале. Аргумент FILEDES — дескриптор, определяющий
     терминал; PGID определяет группу. Вызывающий процесс должен быть членом
     той же сессии, что и PGID и должен иметь тот же управляющий терминал.

     С точки зрения доступа к терминалу эта функция трактуется как вывод. Если
     она вызывается из фонового процесса на его управляющем терминале, то
     обычно всем процессам в жтой группе посылается сигнал «SIGTTOU».
     Исключением является ситуация, когда вызывающий процесс игнорирует или
     блокирует сигнал «SIGTTOU». В этом случае операция выполняется и сигнал
     не будет послан.

     В случае успеха «tcsetpgrp» возвращает «0». Возвращённое значение «-1»
     означает ошибку. Для этой функции определены следующие состояния ошибок
     «errno»:

   «EBADF»
         Аргумент FILEDES не является корректным файловым дескриптором.

   «EINVAL»
         Аргумент PGID некорректен.

   «ENOSYS»
         Система не поддерживает управление заданиями.

   «EPERM»
         Группа процессов PGID не принадлежит той же сессии, что и вызывающий
         процесс.

 -- Function: pid_t tcgetsid (int FILDES)
     Эта функция используется для получения идентификатора группы процессов
     сессии [?], для которой терминал, определяетмый аргументом FILDES,
     является управляющим. Если вызов удачен [успешен], то возвращается
     идентификатор группы. Иначе, возвращается значение «(pid_t) -1» и
     глобальная переменная ERRNO получает одно из следующих значений:

    «EBADF»
          Аргумент FILEDES не является корректным файловым дескриптором.

    «ENOTTY»
          Вызывающий процесс не имеет управляющего терминала, или файл не
          является управляющим терминалом.
