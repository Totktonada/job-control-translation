27.1 Идеи контроля задач

Основное предназначение интерактивного шелла — чтение команд с
пользовательского терминала и создание процессов для выполнения программ,
соответствующих этим командам. Шелл может делать это, используя функции «fork»
(*note Creating a Process::) и «exec» (*note Executing a File::).

Одиночная команда может запустить только один процесс, но часто при этом
используется несколько процессов. Если вы используете оператор «|» в команде
шелла, вы явно запрашиваете запуск нескольких программ, каждая в своём
процессе. Но даже если вы запускаете только одну программу, она может
использовать множество процессов в своей работе. Например, одна команда
компиляции, такая как «cc -c foo.c», как правило использует четыре процесса
(хотя обычно в каждый момент времени используется лишь два). Или, к примеру,
задачей команды «make» является запуск других программ в отдельных процессах.

Процессы, относящиеся к одиночной команде, называются «группой процессов»
(«process group») или «задачей» («job»). Таким образом, вы можете управлять
ими как одним целым. Например, нажатие «C-c» посылает сигнал «SIGINT», который
завершает все процессы в группе, работающей на переднем плане.

Сессия («session») - это бо`льшая совокупность процессов. Обычно все процессы,
запускаемые после авторизации в системе (т.е. потомки программы входа в
систему), принадлежат одной сессии.

Каждый процесс принадлежит группе процессов. Когда процесс создаётся, он
становится членом той же группы и той же сессии, что и родительский процесс.
Вы можете поместить его в другую группу той же сессии, используя функцию
«setpgid».

Единственный способ поместить процесс в другую сессию — сделать его начальным
процессом новой сессии или «лидером сессии» («session leader»), используя
функцию «setsid». Она также помещает лидера сессии в новую группу, при этом
переместить его из этой группы в другую нельзя.

Обычно новая сессия создаётся программой входа в систему, и лидер сессии — это
процесс, запускающий пользовательский шелл после успешной авторизации в
системе.

==== Not checked ====
Шелл, который поддерживает контроль задач, должен контролировать то, которая
из задач может использовать терминал в любое время [безраздельно?]. В
противном случае может существовать более одной задачи, одновременно
пытающейся читать с терминала и путаница с тем, который из процессов должен
получить пользовательский ввод.  Для предотвращения этого, шелл должен
действовать совместно с драйвером терминала, используя протокол, описанный в
этой главе.

Шелл может дать неограниченный доступ к контролю над терминалом только одной
группе процессов в некоторый момент времени. Эта группа процессов называется
«задачей переднего плана», которая контролирует терминал. Другие группы
процессов, управляемые данным шеллом, выполняются без подобного доступа к
терминалу. Они называются «задачами заднего плана».

Если задаче заднего плана нужно читать с контролируемого терминала, это
«пресекается» драйвером терминала, если установлен режим «TOSTOP». Аналогично
и с записью. Пользователь может остановить задачу переднего плана, напечатав
символ SUSP (*note Special Characters::), и программа может остановить любую
задачу, послав сигнал «SIGSTOP» [fuzzy]. Это обязанность шелла - замечать,
когда задача остановилась, для уведомления об этом пользователя, и
предоставление пользователю механизма для интерактивного продолжения
[возобновления работы?] остановленных задач и переключения между задачами
переднего и заднего плана.

См. *Note Access to the Terminal::, для дополнительной информации о
вводе/выводе на контролируемый терминал.

27.2 Контроль задач необязателен

Не все операционные системы поддерживают контроль задач. Система GNU
поддерживает [предоставляет поддержку?] контроль задач, но если вы используете
библиотеку GNU на некоторых других системах, эти системы должны не
поддерживать контроль задач сами.

Вы можете использовать макрос «_POSIX_JOB_CONTROL» для проверки поддержки
системой контроля задач во время компиляции.  *Note System Options::.

Если контроль задач не поддерживается, тогда только одна группа процессов
принадлежит сессии. Эта группа процессов ведёт себя так, как если бы она
всегда находилась на переднем плане. Функции для создания дополнительных групп
процессов просто завершаются неудачей с кодом ошибки «ENOSYS».

Макросы, обозначающие [называющие?] различные сигналы контроля задач (*note
Job Control Signals::) определены, когда контроль задач не поддерживается.
Однако, система никогда не генерирует эти сигналы, и попытка послать сигнал
контроля задач, а также исследовать или определить соответствующие действия,
приведёт к сообщению об ошибки или ни к чему.

27.6.2 Инициализация шелла

Когда шелл, стандартно контролирующий задачи, запустился, он должен
действовать аккуратно, если был вызван из другого шелла, который уже
осуществляет контроль задач.

Дочерний шелл, запущенный интерактивно, должен убедиться, что он помещён на
передний план родительским шеллом перед тем, как начать свой контроль задач.
Он делает это, получая начальный идентификатор группы процессов с помощью
функции "getpgrp" и сравнивая его с идентификатором группы процессов текущей
задачи переднего плана, связанной с контроллируемым терминалом. Последний
идентификатор можно получить, используя функцию "tcgetpgrp".

Если дочерний шелл запущен не как задача переднего плана, он должен
остановиться, послав сигнал "SIGTTIN" своей группе процессов. Он не может
самопроизвольно поместить себя на передний план; он должен ждать пока
пользователь скажет родительскому шеллу сделать это. Если дочерний шелл
продолжает выполнение ["is continued again"], он должен повторить проверку и
остановиться снова, если он всё ещё не на переднем плане.

Однажды дочерний шелл, будучи помещённым на передний план родительским шеллом,
сможет начать свой контроль задач. Для этого он вызывает "setpgid", чтобы
поместить себя в свою собственную группу процессов, и затем "tcsetpgrp", чтобы
поместить эту группу процессов на передний план.

Когда шелл начинает контроль задач, ему следует игнорировать все сигналы
останова подконтрольных задач, для того, чтобы случайно не завершить самого
себя. Вы можете сделать это, установив действие для всех сигналов останова в
"SIG_IGN".

Дочерний шелл, который запущен в неинтерактивном режиме, не может и не должен
осуществлять контроль задач. Он должен оставить все созданные им процессы в
той группе процессов, которой принадлежит сам; это позволяет неинтерактивному
шеллу и его дочерним процессам обрабатываться родительским шеллом как единая
задача. Сделать это легко -- просто не используйте никакие из примитивов
управления задачами -- но вы должны не забыть заставить шелл действовать таким
образом.

Далее представлен код инициализации для примера шелла, который иллюстрирует
всё вышесказанное [не нижесказанное?].

     /* Следите за атрибутами шелла.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Перед тем как продолжить, убедитесь, что шелл работает в интерактивном
	    режиме как задача переднего плана. */

     void
     init_shell ()
     {

       /* Проверьте, работаем ли мы в интерактивном режиме.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Ждите, пока мы не окажемся на переднем плане.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Игнорируйте интерактивные сигналы и сигналы, предназначенные для
			  контроля задач.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Поместите себя в свою собственную группу процессов.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Перехватите контроль над [управление?] терминалом.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Сохраните атрибуты шелла по-умолчанию.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }
