27.6.2 Инициализация шелла

Когда шелл, стандартно контролирующий задачи, запустился, он должен
действовать аккуратно, если был вызван из другого шелла, который уже
осуществляет контроль задач.

Дочерний шелл, запущенный интерактивно, должен убедиться, что он помещён на
передний план родительским шеллом перед тем, как начать свой
контроль задач. Он делает это, получая начальный идентификатор
группы процессов с помощью функции "getpgrp" и сравнивая его с идентификатором
группы процессов текущей задачи переднего плана, связанной с контроллируемым
терминалом. Последний идентификатор можно получить, используя функцию "tcgetpgrp".

Если дочерний шелл запущен не как задача переднего плана, он должен
остановиться, послав сигнал "SIGTTIN" своей группе процессов. Он не может
самопроизвольно поместить себя на передний план; он должен ждать пока
пользователь скажет родительскому шеллу сделать это. Если дочерний шелл
продолжает выполнение ["is continued again"], он должен повторить проверку и остановиться снова, если он всё ещё не на переднем плане.

Однажды дочерний шелл, будучи помещённым на передний план родительским шеллом,
сможет начать свой контроль задач. Для этого он вызывает "setpgid", чтобы
поместить себя в свою собственную группу процессов, и затем "tcsetpgrp", чтобы
поместить эту группу процессов на передний план.

Когда шелл начинает контроль задач, ему следует игнорировать все сигналы
останова подконтрольных задач, для того, чтобы случайно не завершить самого
себя. Вы можете сделать это, установив действие для всех сигналов останова в
"SIG_IGN".

Дочерний шелл, который запущен в неинтерактивном режиме, не может и не должен
осуществлять контроль задач. Он должен оставить все созданные им процессы в
той группе процессов, которой принадлежит сам; это позволяет неинтерактивному
шеллу и его дочерним процессам обрабатываться родительским шеллом как единая
задача. Сделать это легко -- просто не используйте никакие из примитивов
управления задачами -- но вы должны не забыть заставить шелл действовать таким
образом.

Далее представлен код инициализации для примера шелла, который иллюстрирует
всё вышесказанное [не нижесказанное?].

     /* Следите за атрибутами шелла.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Перед тем как продолжить, убедитесь, что шелл работает в интерактивном
	    режиме как задача переднего плана. */

     void
     init_shell ()
     {

       /* Проверьте, работаем ли мы в интерактивном режиме.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Ждите, пока мы не окажемся на переднем плане.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Игнорируйте интерактивные сигналы и сигналы, предназначенные для
			  контроля задач.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Поместите себя в свою собственную группу процессов.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Перехватите контроль над [управление?] терминалом.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Сохраните атрибуты шелла по-умолчанию.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }
