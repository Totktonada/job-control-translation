27 Управление заданиями
***********************

«Управлением заданиями» называется протокол [правила, соглашения?],
позволяющий пользователю переключаться между несколькими «группами процессов»
(или «заданий») («process groups», «jobs») внутри одного сеанса («login
session»). Возможности управления заданиями организованы так, что присущее
большинству программ поведение достигается без дополнительных усилий со
стороны разработчика программы, от него не требуются какие-либо специальные
знания об управлении заданиями. Возможно, вам не понадобится материал этой
главы до тех пор, пока вы не станете писать шелл или программу входа в
систему.

Для понимания материала, представленного в этой главе, вам необходимо
познакомиться с понятиями, относящимися к созданию процессов (*note Process
Creation Concepts::) и обработке сигналов (*note Signal Handling::).

* Содержание:

* Идеи [концепция?] управления заданиями::   Шелл может управлять заданиями.
* Управление заданиями необязательно::       Не все POSIX-совместимые системы поддерживают управление заданиями.
* Управляющий терминал процесса::            Как процесс получает свой управляющий терминал.
* Доступ к управляющему терминалу::          Как процессы делят управляющий терминал.
* Осиротевшие группы процессов::             Задания, остающиеся после выхода пользователя из системы.
* Реализация шелла::                         Что необходимо шеллу для реализации управления заданиями.
* Функции для управления заданиями::         Функции для управления группами процессов.

27.1 Идеи [концепция?] управления заданиями
===========================================

Основное предназначение интерактивного шелла — чтение команд с
пользовательского терминала и создание процессов для выполнения программ,
соответствующих этим командам. Шелл может делать это, используя функции «fork»
(*note Creating a Process::) и «exec» (*note Executing a File::).

/* TODO: вариант. */
Можно подумать, что при запуске одной команды порождается только один
процесс, но част...

При запуске одиночной команды (прим. перев.: вероятно, подразумевался конвеер)
шелл запускает только один процесс, но часто запущенная программа порождает
несколько процессов. Если же вы используете оператор «|» в команде шелла, вы
явно запрашиваете запуск нескольких программ отдельными процессами. Но даже
если вы запускаете только одну программу, она может использовать множество
процессов в своей работе. Например, одна команда компиляции, такая как «cc -c
foo.c», как правило использует четыре процесса (хотя обычно в каждый момент
времени используется лишь два). Или, к примеру, задачей команды «make»
является запуск других программ в отдельных процессах.

/* TODO: вариант. */
Вы можете управлять процессами в одной группе как (как если бы они были) одним
целым.

Процессы, относящиеся к одиночной команде, называются «группой процессов»
(«process group») или «заданием» («job»). Таким образом, вы можете управлять
ими как одним целым. Например, нажатие «C-c» посылает сигнал «SIGINT», который
завершает все процессы в группе, работающей на переднем плане.

Сеанс («session») - это бо`льшая совокупность процессов. Обычно все процессы,
запускаемые после авторизации в системе (т.е. потомки программы входа в
систему), принадлежат одному сеансу.

Каждый процесс принадлежит группе процессов. Когда процесс создаётся, он
становится членом той же группы и того же сеанса, что и родительский процесс.
Вы можете поместить его в другую группу того же сеанса, используя функцию
«setpgid».

Единственный способ поместить процесс в другой сеанс — сделать его начальным
процессом нового сеанса или «лидером сеанса» («session leader»), используя
функцию «setsid». Она также помещает лидера сеанса в новую группу процессов,
при этом переместить его из этой группы в другую нельзя.

Обычно новый сеанс создаётся программой входа в систему, и лидер сеанса — это
процесс, запускающий пользовательский шелл после успешной авторизации в
системе.

Шелл, поддерживающий управление заданиями, обязан следить за тем, что лишь
одно из заданий может безраздельно использовать терминал. В противном случае
может существовать несколько заданий, одновременно пытающихся читать с
терминала, из-за чего возникает путаница с тем, который из процессов должен
получить пользовательский ввод. Чтобы этого избежать, шелл должен
взаимодействовать с драйвером терминала с помощью протокола, описанного в этой
главе.

Шелл может дать неограниченный доступ к управляющему терминалу только одной
группе процессов в некоторый момент времени. Эта группа называется «заданием
переднего плана» («foregroud job») данного управляющего терминала. Другие
группы под управлением данного шелла выполняются без подобного доступа к
терминалу. Они называются «фоновыми заданиями» («background job»).

Если фоновому заданию нужно читать с управляющего терминала, оно
приостанавливается драйвером терминала. Аналогично и с записью, если
установлен режим «TOSTOP». Пользователь может приостановить задание переднего
плана, напечатав символ SUSP (*note Special Characters::), а программа может
приостановить любое задание, послав ему сигнал «SIGSTOP». Шелл должен
отслеживать приостановку заданий и уведомлять об этом пользователя. Также шелл
должен предоставлять механизм запуска приостановленных заданий и механизм
переключения заданий между фоновым режимом работы и режимом переднего плана
[основной режим, интерактивный режим?].

*Note Access to the Terminal::, для дополнительной информации о вводе/выводе
на управляющий терминал.

27.2 Управление заданиями необязательно
=======================================

Не все операционные системы поддерживают управление заданиями. Система GNU
поддерживает [предоставляет поддержку?] управление заданиями, но если вы
используете библиотеку GNU на некоторых других системах, сами эти системы не
должны управлять заданиями.

Вы можете использовать макрос «_POSIX_JOB_CONTROL» для проверки во время
компиляции того, поддерживает ли система управление заданиями. *Note System
Options::.

Если управление заданиями не поддерживается, тогда сеансу принадлежит только
одна группа процессов. Эта группа ведёт себя так, как если бы она всегда
находилась на переднем плане. Функции для создания дополнительных групп просто
завершаются неудачей с кодом ошибки «ENOSYS».

Когда управление заданиями не поддерживается, макросы, обозначающие
[называющие?] соответствующие сигналы (*note Job Control Signals::), всё равно
определены. Однако, система никогда не генерирует эти сигналы, и попытка
послать сигнал управления заданиями, а также получить или изменить
соответствующие действия (функции) либо приведёт к сообщению об ошибке, либо
будет просто проигнорирована.

27.3 Управляющий терминал процесса
==================================

Одним из атрибутов процесса является его управляющий терминал. Дочерние
процессы, созданные с помощью «fork», наследуют управляющий терминал
родительского процесса. Таким образом, все процессы в сеансе наследуют
управляющий терминал лидера сеанса. Лидер сеанса, управляющий терминалом,
называется «управляющим процессом» («controlling process») этого терминала.

В большинстве случаев вам не нужно беспокоиться о правильности работы
механизма, используемого для назначения управляющего терминала для сеанса, так
как этом позаботится система, когда вы авторизуетесь в системе.

Процесс, вызвавший «setsid», чтобы стать лидером нового сеанса, отключается от
своего управляющего терминала. *Note Process Group Functions::.

27.4 Доступ к управляющему терминалу
====================================

Процессы, относящиеся к заданию переднего плана некоторого управляющего
терминала, имеют неограниченный доступ к этому терминалу, в отличие от фоновых
заданий. Этот раздел более детально описывает, что происходит, когда процесс
из фонового задания пытается обратиться к своему управляющему терминалу.

Когда процесс из фонового задания пытается читать со своего управляющего
терминала, группе процессов обычно посылается сигнал «SIGTTIN». Как правило
это приводит к приостановке всех процессов в группе (за исключением случая,
когда они обрабатывают этот сигнал и не приостанавливаются самостоятельно).
Однако, если читающий процесс игнорирует или блокирует этот сигнал, то чтение
завершается неудачей с ошибкой «EIO».

Аналогично, когда процесс из фонового задания пытается писать на свой
управляющий терминал, умолчальным поведением является отправка сигнала
«SIGTTOU» группе процессов. Однако, это поведение можно изменить с помощью
бита «TOSTOP» в локальных флагах режимов («local modes flag») (*note Local
Modes::). Если данный бит не установлен (это значение по умолчанию), тогда
запись на управляющий терминал разрешена всегда, без отправки сигнала. Запись
также разрешена, если сигнал «SIGTTOU» игнорируется или блокируется пишущим
процессом.

Примечания переводчиков к абзацу выше
-------------------------------------

Из текста неясно, что подразумевается в последнем предложении под фразой
«запись разрешена». Рассмотрим случай, когда бит «TOSTOP» установлен и один из
процессов группы делает попытку записи на терминал. Пусть этот процесс
блокирует или игнорирует сигнал «SIGTTOU». Два вопроса:
1. Произойдёт ли запись на терминал?
2. Будет ли послан сигнал «SIGTTOU» другим процессам группы?
Вывод: этот вопрос требует дополнительного исследования.

В абзаце выше есть ещё одна неточность: утверждения о том, что по умолчанию
флаг «TOSTOP» сброшен, и о том, что умолчальным поведением является отправка
сигнала «SIGTTOU» явно противоречат друг другу. Вероятно, подразумевалось, что
умолчальное поведение, в случае если данный флаг установлен, — отправка
сигнала «SIGTTOU».

Конец примечаний переводчиков
-----------------------------

Большинство других операций с терминалом трактуются либо как чтение, либо как
запись. (Как именно, должно быть указано в описании соответствующей операции.)

Для дополнительной информации об основных функциях «read» и «write», смотрите
*note I/O Primitives::.

27.5 Осиротевшие группы процессов
=================================

Когда управляющий процесс завершается, его терминал становится свободным и
новый сеанс может быть создан на нём. (Фактически, другой пользователь может
авторизоваться на этом терминале.) Если любой из процессов из старого сеанса
пытается использовать терминал после этого, то могут возникнуть проблемы.

Для того, чтобы избежать их появления, группы процессов, которые продолжают
работать даже после завершения лидера сеанса, помечаются как «осиротевшие
группы процессов» («orphaned process groups»).

Когда группа процессов становится сиротой, её процессам посылается сигнал
«SIGHUP». Обычно после этого процессы завершаются. Однако, если программа
игнорирует этот сигнал или создаёт обработчик для него (*note Signal
Handling::), она может выполняться далее как осиротевшая группа процессов даже
после завершения управляющего процесса, но уже без доступа к терминалу.

27.6 Реализация шелла, управляющего заданиями
=============================================

Этот раздел описывает, что должен делать шелл для осуществления управления
заданиями. Здесь рассматривается подробный шаблон программы, иллюстрирующий
рассматриваемые концепции [идеи?].

* Содержание:

* Структуры данных::                        Введение в шаблон шелла.
* Инициализация шелла::                     Что должен делать шелл для поддержки
                                                управления заданиями.
* Запуск заданий::                          Создание заданий для выполнения команд.
* Выполнение на переднем плане и в фоне::   Помещение задания на передний план
                                                и в фон.
* Приостановленные и завершённые задания::  Отчёт о статусе задания.
* Запуск приостановленных заданий::         Как запустить приостановленное
                                                задание на переднем плане или в фоне.
* Недостающее::                             Другие части шелла.

27.6.1 Структуры данных шелла
-----------------------------

Все примеры программ, приведённые в данной главе, являются частью простого
шелла. Этот раздел представляет структуры данных и служебные функции, которые
используются всюду в примере.

Шаблон шелла чаще всего обращается к двум структурам данных. Тип «job»
содержит информацию о задании, которое является набором процессов, связанных
вместе пайпами. Тип «process» хранит информацию об одном процессе.
Соответствующие объявления структур данных:

     /* Один процесс. */
     typedef struct process
     {
       struct process *next;       /* следующий процесс в конвеере (в pipeline) */
       char **argv;                /* для exec */
       pid_t pid;                  /* идентификатор процесса */
       char completed;             /* истина, если процесс завершён */
       char stopped;               /* истина, если процесс приостановлен */
       int status;                 /* статус завершения */
     } process;

     /* Задание (конвеер процессов). */
     typedef struct job
     {
       struct job *next;           /* следующее активное задание */
       char *command;              /* командная строка, используется для
                                      сообщений */
       process *first_process;     /* список процессов этого задания */
       pid_t pgid;                 /* идентификатор группы процессов */
       char notified;              /* истина, если пользователю сказано о
                                      завершении задания */
       struct termios tmodes;      /* сохранённые параметры терминала */
       int stdin, stdout, stderr;  /* стандартные каналы ввода/вывода */
     } job;

     /* Активные задания собираются в список. Это его голова («list head»). */
     job *first_job = NULL;

Далее показаны несколько служебных функций, которые используются для действий
над объектами заданий.

     /* Поиск активного задания по PGID (идентификатору группы). */
     job *
     find_job (pid_t pgid)
     {
       job *j;

       for (j = first_job; j; j = j->next)
         if (j->pgid == pgid)
           return j;
       return NULL;
     }

     /* Возвращает истину, если все процессы в задании приостановлены или
        завершены. */
     int
     job_is_stopped (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed && !p->stopped)
           return 0;
       return 1;
     }

     /* Возвращает истину, если все процессы в задании завершены. */
     int
     job_is_completed (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed)
           return 0;
       return 1;
     }

27.6.2 Инициализация шелла
--------------------------

Когда шелл, стандартно управляющий заданиями, запустился, он должен
действовать аккуратно, если был вызван из другого шелла, который уже
осуществляет управление заданиями.

Дочерний шелл, запущенный интерактивно, должен убедиться, что он помещён на
передний план родительским шеллом перед тем, как самому начать управлять
заданиями. Он делает это, получая начальный идентификатор группы процессов с
помощью функции «getpgrp» и сравнивая его с идентификатором группы текущего
задания переднего плана, связанного с управляющим терминалом. Последний
идентификатор можно получить, используя функцию «tcgetpgrp».

Если дочерний шелл запущен в фоновом режиме, он должен приостановиться, послав
сигнал «SIGTTIN» своей группе процессов. Он не может самопроизвольно поместить
себя на передний план и должен ждать пока пользователь скажет родительскому
шеллу сделать это. Если дочерний шелл продолжает выполнение [«is continued
again»], он должен повторить проверку и приостановиться снова, если он всё ещё
не на переднем плане.

Однажды дочерний шелл, будучи помещённым на передний план родительским шеллом,
сможет начать управлять заданиями. Для этого он вызывает «setpgid», чтобы
поместить себя в свою собственную группу процессов, и затем «tcsetpgrp», чтобы
поместить эту группу на передний план.

Когда шелл начинает управлять заданиями, ему следует игнорировать все сигналы
приостановки подконтрольных заданий, для того, чтобы случайно не приостановить
самого себя. Вы можете сделать это, установив действие для всех сигналов
приостановки в «SIG_IGN».

Примечание переводчиков
-----------------------

Согласно POSIX.1-2001 поведение «waitpid»/«wait4» меняется при явном
игнорировании сигнала SIGCHLD. В данном документе эта особенность не
учитывается. Дополнительную информацию можно почитать в разделе «Замечания»
(«Notes») `man waitpid`.

Конец примечания переводчиков
-----------------------------

Дочерний шелл, запущеный в неинтерактивном режиме, не может и не должен
осуществлять управление заданиями. Он должен оставить все созданные им
процессы в той группе, которой принадлежит сам; это позволяет неинтерактивному
шеллу и дочерним по отношению к нему процессам обрабатываться родительским
шеллом как единое задание. Сделать это легко — просто не используйте никакие
из основных функций управления заданиями. Главное, не забудьте заставить шелл
действовать таким образом.

Далее представлен код инициализации для примера шелла, который иллюстрирует
всё вышесказанное.

     /* Следим за атрибутами шелла. */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Перед тем как продолжить, убедимся, что шелл работает в интерактивном
	    режиме как задание переднего плана. */

     void
     init_shell ()
     {

       /* Проверим, работаем ли мы в интерактивном режиме. */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Ждём, пока не окажемся на переднем плане. */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Игнорируем интерактивные сигналы и сигналы, предназначенные для
			  управления заданиями. */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Поместим себя в свою собственную группу процессов. */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Перехватим управление терминалом. */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Сохраним атрибуты шелла по умолчанию. */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }

27.6.3 Запуск заданий
---------------------

Однажды (прим. перев.: см. четвёртый абзац предыдущего раздела) шелл берёт
ответственность за управление заданиями на его управляющем терминале, и тогда
шелл может запускать задания в ответ на команды, набираемые пользователем.

Для создания процессов в группе, вы используете некоторые функции из семейств
«fork» и «exec», они описаны в *note Process Creation Concepts::. С помощью
только этих функций можно запускать программы в дочерних процессах. Однако,
если не учитывать некоторых (чуть более сложных) деталей, то может возникнуть
состояние гонки («race condition»). Поэтому вы должны позаботиться о том,
чтобы делать всё правильно.

Есть два варианта структурирования дерева родственных отношений между
процессами. Вы можете сделать все процессы в группе дочерними по отношению к
процессу шелла или сделать один процесс в группе предком остальных процессов
группы. Пример шелла, представленный в этой главе, использует первый подход,
поскольку это до некоторой степени уменьшает количество рутинных операций.

Непосредственно после порождения каждый из процессов должен поместить себя в
новую группу с помощью вызова «setpgid»; см. *note Process Group Functions::.
Первый процесс в новой группе называется лидером группы процессов («process
group leader»), его идентификатор («process ID») становится идентификатором
группы («process group ID»).

Шелл также должен вызвать «setpgid» для того, чтобы поместить каждый дочерний
процесс в новую группу. Это делается для предотвращения потенциальной проблемы
синхронизации: каждый дочерний процесс нужно поместить в соответствующую
группу процессов перед началом выполнения новой программы (прим. перев.:
вероятно, подразумевалось, что в каждом порождённом процессе «setpgid» должен
быть вызван до «exec»). Кроме того, продолжать выполнение программы шелла
нужно только после того, как все дочерние процессы помещены в новую группу.
Вызов «setpgid» как дочерним процессом, так и шеллом гарантирует, что всё
пройдёт правильно, вне зависимости от того, какой процесс сделал «setpgid»
первым.

Если задание было запущено как задание переднего плана, новую группу процессов
также нужно поместить на передний план на управляющем терминале. Сделать это
можно, используя «tcsetpgrp». Опять же, это нужно сделать как шеллу, так и
каждому из дочерних процессов, чтобы избежать состояния гонки.

Примечание переводчиков
-----------------------

Благодаря вызову «setpgid» и «tcsetpgrp» из порождённого процесса, каждый
процесс задания имеет нужные права на доступ к терминалу на момент вызова
«exec». Благодаря вызову «setpgid» и «tcsetpgrp» из процесса шелла, есть
гарантия, что процессы в задании будут принадлежать одной группе после того,
как задание полностью запустится, а группой процессов переднего плана
управляющего терминала будет считаться группа запущенного задания.

В примере ниже функция «setpgid» вызывается как в дочернем процессе, так и в
основном. Функция «tcsetpgrp» напрямую вызывается только в дочернем процессе,
однако фигурирует в функции «put_job_in_foreground», которая вызывается из
процесса шелла.

Конец примечания переводчиков
-----------------------------

Далее каждый дочерний процесс должен сбросить реакцию на сигналы.

При инициализации процесс шелла устанавливает игнорирование сигналов
управления заданиями; см. *note Initializing the Shell::. В результате этого
все созданные дочерние процессы также игнорируют эти сигналы (по наследству).
Это определённо нежелательно, и каждый процесс должен явно установить действия
для этих сигналов назад в «SIG_DFL» непосредственно после порождения.

Когда шелл следует этому соглашению, приложения могут предпологать, что
реакция на сигналы корректно наследуется от родительского процесса. Но каждое
приложение ответственно за то, чтобы не портить реакцию на сигналы
приостановки. Приложение, отключивщее нормальную интерпретацию символа SUSP,
должно предоставлять другие механизмы для приостановки задания пользователем.
Когда пользователь активирует этот механизм, программа должна послать сигнал
«SIGTSTP» своей группе процессов, а не только своему процессу. *Note Signaling
Another Process::.

Наконец, каждый дочерний процесс должен вызвать «exec» (если предыдущие этапы
прошли нормально). Здесь же (прим. перев.: если это необходимо) надо
осуществить перенаправление стандартных каналов ввода-вывода. В *Note
Duplicating Descriptors:: рассказано, как это сделать.

Ниже представлена функция из примера шелла, предназначенная для запуска
программы. Эта функция выполняется каждым дочерним процессом непосредственно
после того, как его породил шелл, и никогда не возвращает управление («never
returns»).

     void
     launch_process (process *p, pid_t pgid,
                     int infile, int outfile, int errfile,
                     int foreground)
     {
       pid_t pid;

       if (shell_is_interactive)
         {
           /* Поместим процесс в группу и получим для неё доступ к терминалу,
              если необходимо.
              Это делается как шеллом, так и каждым из дочерних процессов, во
              избежание возможного состояния гонки. */
           pid = getpid ();
           if (pgid == 0) pgid = pid;
           setpgid (pid, pgid);
           if (foreground)
             tcsetpgrp (shell_terminal, pgid);

           /* Установим обработчики для сигналов управления заданиями в
              умолчальное значение. */
           signal (SIGINT, SIG_DFL);
           signal (SIGQUIT, SIG_DFL);
           signal (SIGTSTP, SIG_DFL);
           signal (SIGTTIN, SIG_DFL);
           signal (SIGTTOU, SIG_DFL);
           signal (SIGCHLD, SIG_DFL);
         }

       /* Установим стандартные каналы ввода-вывода для нового процесса. */
       if (infile != STDIN_FILENO)
         {
           dup2 (infile, STDIN_FILENO);
           close (infile);
         }
       if (outfile != STDOUT_FILENO)
         {
           dup2 (outfile, STDOUT_FILENO);
           close (outfile);
         }
       if (errfile != STDERR_FILENO)
         {
           dup2 (errfile, STDERR_FILENO);
           close (errfile);
         }

       /* Выполним программу. Убедимся, что мы вышли. */
       execvp (p->argv[0], p->argv);
       perror ("execvp");
       exit (1);
     }

Если шелл запущен неинтерактивно, эта функция не делает ничего с группами
процессов и сигналами. Помните, что шелл, не выполняющий управление заданиями,
должен держать все дочерние процессы в той же группе процессов, в которой
находится сам.

Следующая функция запускает полное задание. После создания дочерних процессов,
она вызывает некоторые другие функции для того, чтобы поместить вновь
созданные задания на передний план или в фон; это обсуждается в *note
Foreground and Background::.

     void
     launch_job (job *j, int foreground)
     {
       process *p;
       pid_t pid;
       int mypipe[2], infile, outfile;

       infile = j->stdin;
       for (p = j->first_process; p; p = p->next)
         {
           /* Установим пайпы, если необходимо. */
           if (p->next)
             {
               if (pipe (mypipe) < 0)
                 {
                   perror ("pipe");
                   exit (1);
                 }
               outfile = mypipe[1];
             }
           else
             outfile = j->stdout;

           /* Породим дочерний процесс. */
           pid = fork ();
           if (pid == 0)
             /* Дочерний процесс. */
             launch_process (p, j->pgid, infile,
                             outfile, j->stderr, foreground);
           else if (pid < 0)
             {
               /* Ветвление (fork) не удалось. */
               perror ("fork");
               exit (1);
             }
           else
             {
               /* Родительский процесс. */
               p->pid = pid;
               if (shell_is_interactive)
                 {
                   if (!j->pgid)
                     j->pgid = pid;
                   setpgid (pid, j->pgid);
                 }
             }

           /* Приведём в порядок пайпы. */
           if (infile != j->stdin)
             close (infile);
           if (outfile != j->stdout)
             close (outfile);
           infile = mypipe[0];
         }

       format_job_info (j, "launched");

       if (!shell_is_interactive)
         wait_for_job (j);
       else if (foreground)
         put_job_in_foreground (j, 0);
       else
         put_job_in_background (j, 0);
     }

27.6.4 Выполнение на переднем плане и в фоне
--------------------------------------------

Рассмотрим действия, которые должен сделать шелл, запускающий задание на
переднем плане, и отличия этих действий от тех, которые нужно выполнить при
запуске фонового задания.

При запуске задания переднего плана шелл должен сначала получить доступ к
управляющему терминалу (прим. перев.: для дочерних процессов) с помощью
«tcsetpgrp». Потом шелл должен ждать приостановки или завершения процессов в
данной группе. Более подробно это обсуждается в *note Stopped and Terminated
Jobs::.

Когда все процессы в группе завершены или приостановлены, шелл должен вернуть
доступ к терминалу для своей группы процессов с помощью повторного вызова
«tcsetpgrp». Сигналы приостановки могут быть вызваны попыткой фонового
процесса ввести или вывести что-либо, а также введённым пользователем символом
SUSP. Эти сигналы посылаются всей группе и обычно при этом все процессы в
задании вместе приостанавливаются.

Задание переднего плана может покинуть терминал в странном состоянии (прим.
перев.: вероятно, подразумевалось, что задание может изменить параметры
терминала), поэтому перед продолжением шелл должен восстановить сохранённые им
заранее параметры терминала. Если задание всего лишь приостановлено, то первым
делом шелл должен сохранить текущие параметры терминала, чтобы восстановить их
позже, когда задание возобновит работу. Функции для работы с параметрами
терминала называются «tcgetattr» и «tcsetattr»; они описаны в *note Terminal
Modes::.

Ниже представлены функции из примера шелла, делающие всё вышеперечисленное.

     /* Поместить задание J на передний план. Если CONT ненулевой,
        восстановить параметры терминала и отправить группе процессов сигнал
        «SIGCONT» для того, чтобы «разбудить» их перед тем как
        заблокироваться. */

     void
     put_job_in_foreground (job *j, int cont)
     {
       /* Поместим задание на передний план. */
       tcsetpgrp (shell_terminal, j->pgid);

       /* Если необходимо, пошлём заданию сигнал продолжения. */
       if (cont)
         {
           tcsetattr (shell_terminal, TCSADRAIN, &j->tmodes);
           if (kill (- j->pgid, SIGCONT) < 0)
             perror ("kill (SIGCONT)");
         }

       /* Ждём отчётов. */
       wait_for_job (j);

       /* Поместим шелл обратно на передний план. */
       tcsetpgrp (shell_terminal, shell_pgid);

       /* Восстановим параметры терминала, принадлежащие шеллу. */
       tcgetattr (shell_terminal, &j->tmodes);
       tcsetattr (shell_terminal, TCSADRAIN, &shell_tmodes);
     }

Если группа процессов запускается как фоновое задание, шелл должен сам
оставаться на переднем плане и продолжать читать команды с терминала.

В примере шелла, для того, чтобы поместить задание в фон, много действий
делать не нужно. Вот функции, используемые для этого:

     /* Поместить задание в фон. Если аргумент cont — истина (true),
        послать группе процессов сигнал «SIGCONT», чтобы «разбудить» их. */

     void
     put_job_in_background (job *j, int cont)
     {
       /* Если необходимо, пошлём заданию сигнал продолжения. */
       if (cont)
         if (kill (-j->pgid, SIGCONT) < 0)
           perror ("kill (SIGCONT)");
     }

27.6.5 Приостановленные и завершённые задания
---------------------------------------------

Когда запускается задание переднего плана, шелл должен заблокироваться до тех
пор, пока все процессы в задании не завершатся или приостановлятся. Это можно
сделать с помощью функции «waitpid»; см. *note Process Completion::.
Используйте параметр «WUNTRACED», чтобы получать статусную информацию о
приоставленных процессах наравне с завершёнными.

Также шелл должен проверять статус фоновых заданий, о завершении или
приостановке которых можно сообщить пользователю; сделать это можно с помощью
«waitpid» с параметром «WHOHANG». Хорошее место для вставки такой проверки на
завершение или приостановку — непосредственно перед выводом приглашения для
новой команды.

Шелл также может получать асинхронные уведомления о том, что стала доступной
статусная информация о дочернем процессе, с помощью создания обработчика для
сигнала «SIGCHLD». *Note Signal Handling::.

В примере шелла, сигнал «SIGCHLD» обычно игнорируется из-за проблемы
одновременного обращения к глобальным структурам данных, используемым шеллом.
Но в некоторые особые моменты времени (когда шелл не использует эти структуры
данных), такие как ожидание ввода с терминала, имеет смысл включить обработчик
для «SIGCHLD». Функция для синхронной (с ожиданием, «synchronous») проверки
статуса (в данном случае, «do_job_notification») может также использоваться в
этом обработчике.

Ниже представлены части примера шелла, отвечающие за проверку статуса заданий
и формирование отчётов для пользователя.

     /* Сохранить статус процесса PID, возвращённый функцией waitpid.
        Вернуть 0, если всё прошло хорошо, иначе ненулевое значение. */

     int
     mark_process_status (pid_t pid, int status)
     {
       job *j;
       process *p;

       if (pid > 0)
         {
           /* Обновим данные, соответствующие процессу. */
           for (j = first_job; j; j = j->next)
             for (p = j->first_process; p; p = p->next)
               if (p->pid == pid)
                 {
                   p->status = status;
                   if (WIFSTOPPED (status))
                     p->stopped = 1;
                   else
                     {
                       p->completed = 1;
                       if (WIFSIGNALED (status))
                         fprintf (stderr, "%d: Terminated by signal %d.\n",
                                  (int) pid, WTERMSIG (p->status));
                     }
                   return 0;
                  }
           fprintf (stderr, "No child process %d.\n", pid);
           return -1;
         }
       else if (pid == 0 || errno == ECHILD)
         /* Нет процессов, готовых к формированию отчёта о них. */
         return -1;
       else {
         /* Другие фатальные ошибки. */
         perror ("waitpid");
         return -1;
       }
     }

     /* Проверка на процессы с доступной статусной информацией, без
        блокировки. */

     void
     update_status (void)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED|WNOHANG);
       while (!mark_process_status (pid, status));
     }

     /* Проверка на процессы с доступной статусной информацией, блокируется
        до тех пор пока не будут сформированы отчёты обо всех процессах в
        переданном задании. */

     void
     wait_for_job (job *j)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED);
       while (!mark_process_status (pid, status)
              && !job_is_stopped (j)
              && !job_is_completed (j));
     }

     /* Сформировать сообщение с информацией о статусе задания для
        пользователя. */

     void
     format_job_info (job *j, const char *status)
     {
       fprintf (stderr, "%ld (%s): %s\n", (long)j->pgid, status, j->command);
     }

     /* Уведомить пользователя о приостановленных и завершённых заданиях.
        Удалить завершённые задания из списка активных. */

     void
     do_job_notification (void)
     {
       job *j, *jlast, *jnext;
       process *p;

       /* Обновим статусную информацию дочерних процессов. */
       update_status ();

       jlast = NULL;
       for (j = first_job; j; j = jnext)
         {
           jnext = j->next;

           /* Если все процессы завершены, сообщим пользователю о завершении
              задания и удалим задание из списка активных. */
           if (job_is_completed (j)) {
             format_job_info (j, "completed");
             if (jlast)
               jlast->next = jnext;
             else
               first_job = jnext;
             free_job (j);
           }

           /* Уведомим пользователя о приостановленных заданиях.
              Пометим их, поскольку мы не хотим печатать уведомление больше
              одного раза. */
           else if (job_is_stopped (j) && !j->notified) {
             format_job_info (j, "stopped");
             j->notified = 1;
             jlast = j;
           }

           /* Не будем говорить ничего о выполняющихся заданиях. */
           else
             jlast = j;
         }
     }

27.6.6 Запуск приостановленных заданий
--------------------------------------

Шелл может возобновить работу приостановленного задания, послав
соответствующей группе процессов сигнал «SIGCONT». Если нужно продолжить
выполнение задания на переднем плане, то сначала шелл должен вызвать
«tcsetpgrp» для получения доступа к терминалу и восстановить сохранённые
настройки терминала. Затем, после возобновления работы задания на переднем
плане, шелл должен ждать приостановки или завершения задания, как если бы оно
было запущено на переднем плане изначально.

Пример шелла обрабатывает как только что созданные, так и возобновляющие
выполнение задания с помощью пары функций «put_job_in_foreground» и
«put_job_in_background». Определения этих функций даны в *note Foreground and
Background::. Когда требуется продолжить приостановленное задание, нужно
передать в одну из этих функций ненулевое значение в качестве аргумента CONT.
Тогда будет послан сигнал «SIGCONT» и сброшены параметры терминала.

Здесь представлена функция, предназначенная для обновления внутренних структур
шелла в соответствии с тем, что задание продолжает выполнение:

     /* Пометить приостановленное задание J как запущенное. */

     void
     mark_job_as_running (job *j)
     {
       Process *p; /* Прим. перев.: вероятно, process */

       for (p = j->first_process; p; p = p->next)
         p->stopped = 0;
       j->notified = 0;
     }

     /* Возобновить выполнение задания J. */

     void
     continue_job (job *j, int foreground)
     {
       mark_job_as_running (j);
       if (foreground)
         put_job_in_foreground (j, 1);
       else
         put_job_in_background (j, 1);
     }

27.6.7 Недостающее
------------------

Отрывки кода, включённые в эту главу и составляющие пример шелла, — лишь
только часть полного шелла. В частности, никто не говорит о том, как для
структур данных «job» и «program» (прим. перев.: вероятно, имеется ввиду
«process») распределяется память и как проходит их инициализация.

Большинство настоящих шеллов предоставляют сложный пользовательский интерфейс
с поддержкой командного языка, переменных, аббревиатур, подстановок, шаблонов
для подбора имён файлов и прочего подобного. Всё это очень сложно изложить
здесь! Вместо этого мы сосредоточили рассмотрение на том, как реализуются
основные моменты создания процессов, а также на функциях управления заданиями,
которые могут быть вызваны из такого шелла.

Ниже представлена таблица, обобщающая информацию об обозначенных ключевых
моментах:

`void init_shell (void)'
     Инициализация внутренних структур шелла. *Note Initializing the Shell::.

`void launch_job (job *J, int FOREGROUND)'
     Запуск задания J как задания переднего плана или фонового. *Note
     Launching Jobs::.

`void do_job_notification (void)'
     Проверка и уведомление обо всех завершённых или приостановленных
     заданиях. Может вызываться синхронно (с ожиданием, «synchronously») или
     из обработчика для сигнала «SIGCHLD».  *Note Stopped and Terminated
     Jobs::.

`void continue_job (job *J, int FOREGROUND)'
     Возобновление выполнения задания J. *Note Continuing Stopped Jobs::.

Конечно, настоящему шеллу желательно также предоставлять другие функции для
управления заданиями. Например, команды для вывода списка активных заданий или
для посылки заданию сигнала (такого, как «SIGKILL»).

27.7 Функции для управления заданиями
=====================================

==== TODO Not checked ====

Этот раздел содержит подробное описание функций, относящихся к управлению
заданиями.

* Содержание:

* Опознание терминала::          Определение имени управляющего терминала.
* Функции групп процессов::      Функции для управления группами процессов.
* Функции доступа к терминалу::  Функции для управления доступом к терминалу.

27.7.1 Опознание управляющего терминала
---------------------------------------

==== TODO Not checked ====

Для получения имени файла, которое можно использовать для доступа [to open] к
управляющему терминалу, вы можете использовать функцию «ctermid». В библиотеке
GNU она всегда возвращает строку "/dev/tty". Это специальное «магическое»
[«волшебное»] имя файла [или просто «значение»?], которое ссылается на
управляющий терминал текущего процесса (если таковой имеется). Для получения
уникального имени устройства терминала используйте «ttyname»; *note Is It a
Terminal::.

   Функция «ctermid» объявлена в заголовочном файле «stdio.h».

 -- Function: char * ctermid (char *STRING)
    Функция «ctermid» возвращает строку, содержащую имя файла,
    соответствующего управляющему терминалу текущего процесса. Если STRING —
    не нулевой указатель, то это должен быть массив, который может хранить как
    минимум «L_ctermid» символов; строка будет помещена в этот массив. В
    противном случае, будет возвращён указатель на строку в статической
    области памяти, которая может быть перезаписана последующими вызовами
    данной функции.

    Если имя файла не может быть определено по любой из возможных причин, то
    будет возвращена пустая строка. Даже если имя файла было возвращено,
    доступ к нему не гарантируется.

 -- Macro: int L_ctermid
     Значением данного макроса является целочисленное константное выражение,
     соответствующее размеру строки, которого достаточно для хранения имени
     файла, возвращённого функцией «ctermid».

   См. также функции «isatty» и «ttyname» в *note Is It a Terminal::.

27.7.2 Функции групп процессов

==== TODO Not checked ====

Здесь описаны функции для управления группами процессов (прим. перев.: и
сеансами). Для их использования ваша программа должна подключать (include)
заголовочные файлы «sys/types.h» и «unistd.h».

 -- Function: pid_t setsid (void)
     Функция «setsid» создаёт новый сеанс. Вызывающий процесс становится
     лидером сеанса и помещается в новую группу с таким же идентификатором
     (process group ID), как и у данного процесса (process ID).
     Непосредственно после вызова данной функции других процессов в новой
     группе не будет, равно как и не будет других групп в новом сеансе.

     Также, если функция завершилась успешно, процесс перестаёт быть
     привязанным к какому-либо управляющему терминалу.

     Если функция «setsid» завершается успешно, то она возвращает
     идентификатор новой группы вызывающего процесса. Возвращаемое значение
     «-1» означает ошибку. Для этой функции определены следующие значения
     «errno»:

     «EPERM»
           Вызывающий процесс уже является лидером группы или другая группа
           занимает нужный идентификатор.

 -- Function: pid_t getsid (pid_t PID)
     Функция «getsid» возвращает идентификатор группы процессов лидера того
     сеанса, которому принадлежит указанный процесс. Если PID равен «0»,
     подразумевается текущий процесс.

     При ошибке возвращается «-1» и устанавливается переменная «errno». Для
     этой функции определены следующие значения «errno»:

    «ESRCH»
          Нет процессов с данным идентификатором PID.

    «EPERM»
          Вызывающий процесс и процесс, указанный [заданный] с помощью PID,
          находятся в разных сеансах, и реализация не разрешает доступ из
          текущего процесса к идентификатору группы лидера того сеанса, к
          которому принадлежит процесс с идентификатором PID.

Функция «getpgrp» имеет два определения: одно из BSD Unix, а другое из
стандарта POSIX.1. Выбранная возможность test macros [TODO] (*note Feature
Test Macros::) определяет, которое из определений вы получаете. А именно, если
вы определили «_BSD_SOURCE», то получите версию из BSD; если вы определили
«_POSIX_SOURCE» или «_GNU_SOURCE», то получите версию POSIX. Программы,
написанные для старых систем BSD, не будут подключать (include) «unistd.h»,
который определяет «getpgrp» специально под «_BSD_SOURCE». Вы должны
компоновать такие программы с параметром «-lbsd-compat» для получения
определений из BSD.

 -- POSIX.1 Function: pid_t getpgrp (void)
     Определение функции «getpgrp» из POSIX.1 возвращает идентификатор группы
     вызывающего процесса.

 -- BSD Function pid_t getpgrp (pid_t PID)
     Определение функции «getpgrp» из BSD возвращает идентификатор группы
     процесса PID. Вы можете указать значение «0» для аргумента PID для
     получения информации о вызывающем процессе.

 -- System V Function: int getpgid (pid_t PID)
     Функция «getpgid» — то же самое, что и функция «getpgrp» в BSD. Возвращает
     идентификатор группы процесса PID. Можно указать «0» в качестве аргумента
     PID для получения информации о вызывающем процессе.

При ошибке возвращается значение «-1» и устанавливается переменная «errno».
Для этой функции определены следующие значения «errno»:

    «ESRCH»
          Нет процесса с данным идентификатором PID. Вызывающий процесс и
          процесс, указанный [заданный] с помощью PID, находятся в разных
          сеансах, и реализация не разрешает доступ из текущего процесса к
          идентификатору группы лидера того сеанса, к которой принадлежит
          процесс с идентификатором PID.

 -- Function: int setpgid (pid_t PID, pid_t PGID)
     Функция «setpgid» помещает процесс PID в группу PGID. PID и PGID могут
     быть нулями для обозначения вызывающего процесса.

Эта функция завершается неудачей на системах, которые не поддерживают
управление заданиями. *Note Job Control is Optional::, для дополнительной
информации.

Если операция успешна, то функция «setpgid» возвращает нуль. В противном
случае, возвращается «-1». Для этой функции определены следующие значения
«errno»:

    «EACCES»
          Дочерний процесс с идентификатором PID выполнил функцию «exec» после
          того, как ответвился (was forked).

    «EINVAL»
          Значение PGID некорректно.

    «ENOSYS»
          Система не поддерживает управление заданиями.

    «EPERM»
         Определяемый аргументом PID процесс — лидер сеанса, или принадлежит
         не тому же сеансу, что вызывающий процесс, или значение аргумента
         PGID не соответствует идентификатору группы из того же сеанса, что и
         вызывающий процесс.

    «ESRCH»
         Определяемый аргументом PID процесс не является вызывающим
         процессом или дочерним по отношению к вызывающему.

 -- Function: int setpgrp (pid_t PID, pid_t PGID)
     Это имя функции «setpgid» из BSD Unix. Обе функции абсолютно идентичны.

27.7.3 Функции для управления доступом к терминалу

==== TODO Not checked ====

Это функции для чтения и установки группы процессов переднего плана
определённого терминала. Для их использования ваша программа [ваше
приложение?] должна подключать (include) заголовочные файлы «sys/types.h» и
«unistd.h».

Хотя эти функции принимают в качестве аргумента файловый дескриптор,
определяющий [задающий] устройство терминала, задание переднего плана
ассоциировано с файлом терминала само по себе и специально открывать файл [в
оригинале file descriptor] не требуется [не следует/не нужно?].

 -- Function: pid_t tcgetpgrp (int FILEDES)
     Эта функция возвращает идентификатор группы процессов переднего плана,
     ассоциированной с открытым на дескрипторе FILEDES терминалом.

     Если нет групп процессов переднего плана, то возвращается число, большее
     «1», которое не соответствует ни одному идентификатору группы. Эта
     ситуация может иметь место [Это может произойти], если все процессы в
     задании, которое прежде было на переднем плане, завершились и других
     заданий на передний план перемещено не было.

     При ошибке возвращается значение «-1». Для этой функции определены
     следующие значения «errno»:

   «EBADF»
         Аргумент FILEDES не является корректным файловым дескриптором.

   «ENOSYS»
         Система не поддерживает управление заданиями.

   «ENOTTY»
         Файл терминала, соответствующий аргументу FILEDES, не является
         управляющим терминалом вызывающего процесса.

 -- Function: int tcsetpgrp (int FILEDES, pid_t PGID)
     Эта функция используется для того, чтобы задать группу процессов
     переднего плана для терминала. Аргумент FILEDES — соответствующий
     терминалу дескриптор; PGID — идентификатор группы. Вызывающий процесс
     должен быть членом того же сеанса, что и PGID и должен иметь тот же
     управляющий терминал.

     С точки зрения доступа к терминалу эта функция трактуется как вывод. Если
     она вызывается из фонового процесса на его управляющем терминале, то
     обычно всем процессам в этой группе посылается сигнал «SIGTTOU».
     Исключением является ситуация, когда вызывающий процесс игнорирует или
     блокирует сигнал «SIGTTOU». В этом случае операция выполняется и сигнал
     не будет послан.

     В случае успеха «tcsetpgrp» возвращает «0». Возвращённое значение «-1»
     означает ошибку. Для этой функции определены следующие значения «errno»:

   «EBADF»
         Аргумент FILEDES не является корректным файловым дескриптором.

   «EINVAL»
         Аргумент PGID некорректен.

   «ENOSYS»
         Система не поддерживает управление заданиями.

   «EPERM»
         Группа процессов PGID не принадлежит тому же сеансу, что и вызывающий
         процесс.

 -- Function: pid_t tcgetsid (int FILDES)
     Эта функция используется для получения идентификатора группы процессов
     сеанса [?], для которого терминал, определяетмый аргументом FILDES,
     является управляющим. Если вызов удачен [успешен], то возвращается
     идентификатор группы. Иначе, возвращается значение «(pid_t) -1» и
     глобальная переменная ERRNO получает одно из следующих значений:

    «EBADF»
          Аргумент FILEDES не является корректным файловым дескриптором.

    «ENOTTY»
          Вызывающий процесс не имеет управляющего терминала, или файл не
          является управляющим терминалом.
